[{"title":"YOLOv5目标识别使用方法","url":"/合集/编程/YOLOv5目标识别使用方法/","content":"\n## 预备\n\n- python环境和python知识\n- 下载YOLOv5代码（[ultralytics/yolov5: YOLOv5 🚀 in PyTorch > ONNX > CoreML > TFLite (github.com)](https://github.com/ultralytics/yolov5)\n- 安装YOLOv5的依赖库\n  - 指令: `pip install -r requirements.txt`\n\n## 训练数据集准备\n\n官方推荐使用roboflow（[Roboflow: Give your software the power to see objects in images and video](https://roboflow.com/)）这个网站进行数据集的标注，*该网站需要翻墙才能访问*。\n\n### roboflow使用\n\n1. 注册一个账号\n2. 添加`Workspace`\n\n![image-20220809211233745](yolov5目标识别使用方法/image-20220809211233745.png)\n\n3. 创建`Project`\n\n![image-20220809211302483](yolov5目标识别使用方法/image-20220809211302483.png)\n\n4. 在`Project`中上传图片\n\n![image-20220809211342256](yolov5目标识别使用方法/image-20220809211342256.png)\n\n![image-20220809211627912](yolov5目标识别使用方法/image-20220809211627912.png)\n\n上传完成后点击右上角绿色的`Finish Uploading`\n\n![image-20220809211658335](yolov5目标识别使用方法/image-20220809211658335.png)\n\n5. 分配任务\n\n由于roboflow支持多人合作，所以要将图片标注任务分配给某个人，如果是自己一个人做，分配给自己即可。\n\n![image-20220809211731031](yolov5目标识别使用方法/image-20220809211731031.png)\n\n6. 开始标注\n\n点击左侧`Annotate`，选择`ANNOTATING`中的任务开始标注。\n\n![image-20220809211914894](yolov5目标识别使用方法/image-20220809211914894.png)\n\n![image-20220809212031832](yolov5目标识别使用方法/image-20220809212031832.png)\n\n图片中可以标注多个类别。\n\n**注意，图中所有你需要分类的类别都要做好标注，例如上图中有多个`rock`图像，那么它们都应当被标注出来。**\n\n7. 生成数据集\n\n标注完成的图片会被放入`Annotated`目录下，点击右上角的`Add to Dataset`可以生成数据集。你可以设置测试集、验证集、训练集的比例。\n\n![image-20220809212337706](yolov5目标识别使用方法/image-20220809212337706.png)\n\n8. 导出\n\n点击左侧`Generate`准备导出数据集，可以自行决定是否需要预处理和数据增强。YOLO自带图片处理，训练集的图片可以是不同的大小，所以可以不用图片预处理。\n\n![image-20220809212512551](yolov5目标识别使用方法/image-20220809212512551.png)\n\n点击`Versions`，点击右上角的`Export`导出，选择YOLOv5。\n\n![image-20220809212601963](yolov5目标识别使用方法/image-20220809212601963.png)\n\n![image-20220809212636940](yolov5目标识别使用方法/image-20220809212636940.png)\n\n## 训练模型\n\n训练时使用开发者提供的预训练模型，预训练模型分为多个大小。越小的模型运算速度越快，精度越低；越大的模型运算速度越慢，精度越高。如果没有下载预训练模型，程序会自动下载`yolov5s.pt`。\n\n预训练模型同样也在github仓库中可以下载到。\n\n![image-20220809212925936](yolov5目标识别使用方法/image-20220809212925936.png)\n\n在项目目录下，有train.py文件，直接用它就可以训练了，train.py中参数接受代码为：\n\n```python\ndef parse_opt(known=False):\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--weights', type=str, default=ROOT / 'yolov5s.pt', help='initial weights path')\n    parser.add_argument('--cfg', type=str, default='', help='model.yaml path')\n    parser.add_argument('--data', type=str, default=ROOT / 'data/coco128.yaml', help='dataset.yaml path')\n    parser.add_argument('--hyp', type=str, default=ROOT / 'data/hyps/hyp.scratch-low.yaml', help='hyperparameters path')\n    parser.add_argument('--epochs', type=int, default=300)\n    parser.add_argument('--batch-size', type=int, default=16, help='total batch size for all GPUs, -1 for autobatch')\n    parser.add_argument('--imgsz', '--img', '--img-size', type=int, default=640, help='train, val image size (pixels)')\n    parser.add_argument('--rect', action='store_true', help='rectangular training')\n    parser.add_argument('--resume', nargs='?', const=True, default=False, help='resume most recent training')\n    parser.add_argument('--nosave', action='store_true', help='only save final checkpoint')\n    parser.add_argument('--noval', action='store_true', help='only validate final epoch')\n    parser.add_argument('--noautoanchor', action='store_true', help='disable AutoAnchor')\n    parser.add_argument('--noplots', action='store_true', help='save no plot files')\n    parser.add_argument('--evolve', type=int, nargs='?', const=300, help='evolve hyperparameters for x generations')\n    parser.add_argument('--bucket', type=str, default='', help='gsutil bucket')\n    parser.add_argument('--cache', type=str, nargs='?', const='ram', help='--cache images in \"ram\" (default) or \"disk\"')\n    parser.add_argument('--image-weights', action='store_true', help='use weighted image selection for training')\n    parser.add_argument('--device', default='', help='cuda device, i.e. 0 or 0,1,2,3 or cpu')\n    parser.add_argument('--multi-scale', action='store_true', help='vary img-size +/- 50%%')\n    parser.add_argument('--single-cls', action='store_true', help='train multi-class data as single-class')\n    parser.add_argument('--optimizer', type=str, choices=['SGD', 'Adam', 'AdamW'], default='SGD', help='optimizer')\n    parser.add_argument('--sync-bn', action='store_true', help='use SyncBatchNorm, only available in DDP mode')\n    parser.add_argument('--workers', type=int, default=8, help='max dataloader workers (per RANK in DDP mode)')\n    parser.add_argument('--project', default=ROOT / 'runs/train', help='save to project/name')\n    parser.add_argument('--name', default='exp', help='save to project/name')\n    parser.add_argument('--exist-ok', action='store_true', help='existing project/name ok, do not increment')\n    parser.add_argument('--quad', action='store_true', help='quad dataloader')\n    parser.add_argument('--cos-lr', action='store_true', help='cosine LR scheduler')\n    parser.add_argument('--label-smoothing', type=float, default=0.0, help='Label smoothing epsilon')\n    parser.add_argument('--patience', type=int, default=100, help='EarlyStopping patience (epochs without improvement)')\n    parser.add_argument('--freeze', nargs='+', type=int, default=[0], help='Freeze layers: backbone=10, first3=0 1 2')\n    parser.add_argument('--save-period', type=int, default=-1, help='Save checkpoint every x epochs (disabled if < 1)')\n    parser.add_argument('--seed', type=int, default=0, help='Global training seed')\n    parser.add_argument('--local_rank', type=int, default=-1, help='Automatic DDP Multi-GPU argument, do not modify')\n\n    # Weights & Biases arguments\n    parser.add_argument('--entity', default=None, help='W&B: Entity')\n    parser.add_argument('--upload_dataset', nargs='?', const=True, default=False, help='W&B: Upload data, \"val\" option')\n    parser.add_argument('--bbox_interval', type=int, default=-1, help='W&B: Set bounding-box image logging interval')\n    parser.add_argument('--artifact_alias', type=str, default='latest', help='W&B: Version of dataset artifact to use')\n\n    opt = parser.parse_known_args()[0] if known else parser.parse_args()\n    return opt\n```\n\n参数很多，有兴趣可以一一阅读并尝试，在这里只给出最基础的。\n\n建议新建一个批处理文件run_train.bat，这样每次运行不需要重新写参数，也看得更舒服。\n\n```bash\npython -m train\n--batch-size 8 ^\n--epochs 10 ^\n--data dataset/data.yml ^\n--weights yolov5s.pt ^\n--name mymodel ^\n```\n\ndata参数是数据集的配置文件，这个data.yml在roboflow导出时会自动生成，在这里个文件中你要注意`train`和`val`二者的路径，如果不是把数据集直接放在yolov5的根目录下，那么你需要修改这两个路径让它们指向正确的位置。\n\nweights参数是加载的模型参数，如果你下载了预训练模型，那么就把预训练模型的地址填进去。这一项可以缺省，如果缺省会自动下载yolov5s.pt。注意，当你完成训练后，**如果将来想继续在原有的基础上训练模型，那么要把weights改成你想要继续训练的那个模型的地址**。\n\nname参数是训练结果的保存文件夹，默认保存到名为exp的文件夹中，你可以自定义它的名字。训练出来的模型将被保存在name文件夹下的weights文件夹中，分别是best.pt和last.pt——训练时效果最好的模型和最后一次更新的模型。\n\n## 模型使用\n\n如果你需要使用你训练好的模型进行预测，这里不推荐使用工程目录下的eval文件，我们可以自己实现。\n\n```python\nimport numpy as np\nimport torch\ndef detect(self, img0):\n    '''\n    img0: raw img\n    return: pred [[x1, y1, x2, y2, p, cls_id], [...]] or None 如果什么都没检测出来\n    (x1, y1): 方框左上角坐标\n    (x2, y2): 方框右下角坐标\n    p: 目标属于这个分类的概率（神经网络认为目标有多像这个分类）\n    cls_id: 类别id，类别id对应的类别标签可以在data.yml配置文件中查看\n    '''\n    # 1. 将图像处理成适配网络的尺寸\n    from utils.augmentations import letterbox \n    # letterbox是yolov5的图像处理函数，yolov5可以输出各种尺寸不同的图像，它会自动调整\n    img1 = letterbox(img0)[0]\n    img1 = img1.transpose((2, 0, 1))[::-1] # HWC -> CHW, BGR -> RGB\n    img1 = np.ascontiguousarray(img1) # 转换为内存中连续存储的数组，加快运行速度\n\n    img = torch.from_numpy(img1)\n    img = img.float()        \n    img /= 255\n    img = img.unsqueeze(0)\n\n    # 2. 预测\n    pred = model(img)[0]\n    # pred[0]是预测结果\n    # pred[1]是其他的参数\n\n    # 3. 去除重叠\n    from utils.general import non_max_suppression\n    # non_max_suppression是yolov5的内置函数，他用来消除部分重叠\n    # 对于同一个目标来说，你可以用好多个框将其划出，使用这个函数可以消除这些「明明是同一个目标却用多个方框框出来」的现象\n    pred = non_max_suppression(pred,\n            conf_thres=0.4, # 只标注可能性大于该值的目标\n            iou_thres=0.2 # iou越大越能接受重叠\n            )\n\n\n    from utils.general import scale_coords\n    # 4. 放大还原  \n    for det in pred:\n        if det is not None and len(det):  # det不为空而且长度不为0 # 一张图像中的所有目标进行放大\n            # scale_coords是yolov5中的内置函数，因为在输入神经网络时要求特定的尺寸，所以图片时经过缩放的，同时图片中相应的方框坐标也是0-1之间的浮点数\n            # 通过这个函数可以将神经网络输出的预测值映射为原图像上对应的像素坐标\n            det[:, 0:4] = scale_coords(\n                img.shape[2:], # 缩小后的图像大小\n                det[:, 0:4], # 预测的目标的坐标\n                img0.shape  # 原始图像大小\n                ).round()# 四舍五入\n\n    if pred[0] is not None:\n        return pred[0].cpu().detach().numpy() # x1, y1, x2, y2, p, cls_id\n    else:\n        return None\n```\n\n以上的代码与eval中的处理流程基本一致，优点是可以直接获得预测值，后续操作更加灵活。\n\n后续你可以在图片上画上方框和标签：\n\n```python\npred = self.detect(img) # 这个img是你输入的img，注意img格式为HWC\nimg = cv2.cvtColor(img, cv2.COLOR_RGB2BGR) \nfor p in pred:\n    img = cv2.rectangle(img, (int(p[0]), int(p[1])), (int(p[2]), int(p[3])), (255,255,255), 10)\n    img = cv2.putText(img, classes_list[int(p[5])] + \" \" + str(int(p[4].item() * 100)) + \"%\", (int(p[0])+np.random.randint(20),int(p[1])), # classes_list是根据data.yml定义的类别索引\n    cv2.FONT_HERSHEY_SIMPLEX ,\n    1,\n    (240,237,133),\n    3,\n    cv2.LINE_AA)\ncv2.imwrite(\"img.jpg\", img) # 图片会被保存到本地\n```\n\n效果如下：\n\n![19](YOLOv5目标识别使用方法/19.jpg)\n\n如果是要做视频内容的预测也是一样的，把每一帧作为图像输入，获得预测结果后在每一帧图像上绘制方框，并将处理后的图像显示到UI界面上即可。\n\n## 参考资料\n\n[yolov5/README.md at master · ultralytics/yolov5 (github.com)](https://github.com/ultralytics/yolov5/blob/master/README.md)\n[yolov5预测 - 简书 (jianshu.com)](https://www.jianshu.com/p/a041115002e8)\n[Detecting objects with YOLOv5, OpenCV, Python and C++ | by Luiz doleron | MLearning.ai | Medium](https://medium.com/mlearning-ai/detecting-objects-with-yolov5-opencv-python-and-c-c7cf13d1483c)\n\n","tags":["编程","技术","AI"],"categories":["编程"]},{"title":"2022.4动画推荐","url":"/合集/动画推荐/2022_4 动画推荐/","content":"\n{% note warning %} \n\n**主观判断警告**!\n\n本文纯粹出于笔者个人主观经验与感受而成，如有任何不同意见欢迎友善交流讨论\n\n没有提到的作品笔者没看，或不符合笔者个人兴趣，或观看价值较低\n\n另外，本文不提供动画简介，对感兴趣的动画可以点击「更多信息」访问[Bangumi 番组计划](https://bangumi.tv/)网站的详情页面\n\n{% endnote %}\n\n## であいもん（相合之物）\n\n![333664_d4Py9](333664_d4Py9.jpg)\n\n推荐度：95分\n\n以和果子作为线索讲述人与人之间情感的故事。全篇的故事温馨，故事发生的地点是京都，充满古典气息的京都，加上传统的和果子，再加上人物的京都腔，营造了温馨祥和、远离喧嚣的宁静感。我想，就算是不喜欢平淡的日常番的人，只要听到op曲「菫」响起，他那颗焦躁的心也能立刻平静下来，投入到剧情之中。\n\n女主角一果是一个小女孩，但由于她家庭的原因，她身上有着超出一般孩童的成熟。或许正是这样的反差让一果更加惹人怜爱。\n\n全篇充满了人类美好情感的展现，相信本作能为您因世间的冷漠而疲惫的灵魂带来一丝治愈。\n\n更多信息：[であいもん | Bangumi 番组计划](https://bangumi.tv/subject/333664)\n\n关键词：`治愈`，`日常`\n\n## かぐや様は告らせたい-ウルトラロマンティック-（辉夜大小姐想让我告白-超级浪漫-）\n\n![317613_bpGX4](317613_bpGX4.jpg)\n\n推荐度：95分\n\n辉夜大小姐第三季，高质量校园恋爱喜剧，第三季结尾没有断章，在很舒服的地方结束。辉夜大小姐本身就是与传统恋爱故事不同的作品，剧情相当有趣，人设也让人印象深刻。虽然原作漫画越来越烂了，但动画的内容、制作、配音、配乐等方面都是一流的，非常值得一看。\n\n动画表现力很强，配乐质量高，本季中辉夜和会长的恋爱进程也有了极大的进展。在各个方面都属上乘，推荐观看。\n\n更多信息：[かぐや様は告らせたい-ウルトラロマンティック- | Bangumi 番组计划](https://bangumi.tv/subject/317613)\n\n关键词：`恋爱`，`搞笑`，`青春`，`校园`\n\n## SPYxFAMILY（间谍过家家）\n\n![329906_hmtVD](329906_hmtVD.jpg)\n\n推荐度：90分\n\n本作讲述了间谍黄昏为了某个绝密任务而组建家庭，在这期间发生的家庭喜剧故事。主要是过家家，间谍、杀手、超能力者只是让千篇一律的家庭日常变得更有趣的调味品而已。如果是想看的是「间谍」的故事，那或许这部动画并不能满足您的需求。\n\n总之是轻松的日常类型喜剧，主要看点是阿尼亚卖萌。\n\n更多信息：[SPY×FAMILY | Bangumi 番组计划](https://bangumi.tv/subject/329906)\n\n关键词：`家庭喜剧`，`日常`，`萌`\n\n## 本好きの下剋上～司書になるためには手段を選んでいられません～ 第3期（小书痴的下克上～为了成为图书管理员而不择手段～ 第3部）\n\n![310263_Gc74x](310263_Gc74x.jpg)\n\n推荐度：80分\n\n本作第一季观感还是相当不错的，转生后渴望看书而做出种种努力，同时又有身为平民却又贵族魔力的凤傲天设定。但是本季动画基本没什么有趣的剧情，没有读过原作，但是第三季的结局应该是一个比较大的转折，后面的剧情或许会更加精彩，如果还有第四季我认为值得期待。\n\n更多信息：[本好きの下剋上～司書になるためには手段を選んでいられません～ 第3部 | Bangumi 番组计划](https://bangumi.tv/subject/310263)\n\n关键词：`异世界`，`奇幻`，`日常`，`穿越`\n\n## まちカドまぞく 2丁目（街角魔族 2丁目）\n\n![313852_Msy6s](313852_Msy6s.jpg)\n\n推荐度：80分\n\n与小书痴一样，街角魔族第二季不如第一季有趣。在第一季中，出现了如怪力魔法少女，超高速变身读秒，体弱笨蛋魔族之类的有趣设定，但是到了第二季还是在重复第一季的这些梗，缺乏新意，难免有些审美疲劳。不过对于轻百合来说剧情也不算过于白开水，老粉可以一看。\n\n更多信息：[まちカドまぞく 2丁目 | Bangumi 番组计划](https://bangumi.tv/subject/313852)\n\n关键词：`日常`，`搞笑`，`轻百合`\n\n## 理系が恋に落ちたので証明してみた。r=1-sinθ（ 理科生坠入情网故尝试证明 r=1-sinθ ）\n\n推荐度：75分\n\n和上面的两部一样，第二季不如第一季，问题同样是缺乏新意。原本「理科思维在恋爱环境下的使用，理性与感性的错位导致的荒诞而引发的喜剧效果」是这部作品有别于其他恋爱作品的亮点，比如说明明是去游乐园约会，正常人只是规划好时间地点，打扮好自己就去了，但是他们却要把游乐园的游玩当做NLP问题求解，这种反差正是剧情有趣的地方。\n\n在这一季中没有让我看到这些亮点，或者说相比上一季要少很多。不仅如此，这一季还莫名其妙讲了奏的故事，并且这个故事并不有趣，出现在这个作品里我觉得是个败笔。\n\n总体来说这一季虽然不出彩，但也没有特别大的雷，看过第一季的动画党再看第二季补剧情问题不大。\n\n更多信息：[理系が恋に落ちたので証明してみた。r=1-sinθ | Bangumi 番组计划](https://bangumi.tv/subject/317042)\n\n关键词：`恋爱`，`搞笑`，`校园`\n\n## 処刑少女の生きる道（处刑少女的生存之道）\n\n![326871_6Sp4i](326871_6Sp4i.jpg)\n\n推荐度：65分\n\n稍有些猎奇的轻百合，第一话看下来还挺有意思，但是后续就稍有些无聊了，介于百合贴贴和战斗之间，在我看来有些不爽。而且就这一季来说，感觉剧情基本没有多少推进，作为动画党来说很可能观感会比较差。话虽如此，作画和人设还不错，当做爆米花动画看看养眼也不算差。\n\n更多信息：[処刑少女の生きる道 | Bangumi 番组计划](https://bangumi.tv/subject/326871)\n\n关键词：`奇幻`，`战斗`，`极轻微百合`\n\n## 其他龙傲天\n\n纯粹的爆米花龙傲天，不用带脑子看就完事了。\n\n### 勇者、辞めます（勇者，辞职不干了）\n\n![353657_0xz2K](353657_0xz2K.jpg)\n\n[勇者、辞めます | Bangumi 番组计划](https://bangumi.tv/subject/353657)\n\n### 史上最強の大魔王、村人Aに転生する（史上最强的大魔王转生为村民A）\n\n![330055_AHxG5](330055_AHxG5.jpg)\n\n[史上最強の大魔王、村人Aに転生する | Bangumi 番组计划](https://bangumi.tv/subject/330055)\n\n### 骸骨騎士様、只今異世界へお出掛け中（骸骨骑士大人异世界冒险中）\n\n![333448_fs5AX](333448_fs5AX.jpg)\n\n[骸骨騎士様、只今異世界へお出掛け中 | Bangumi 番组计划](https://bangumi.tv/subject/333448)","tags":["二次元","动画"],"categories":["动画推荐"]},{"title":"英语-虚拟语气","url":"/英语-虚拟语气/","content":"\n# 英语动词语气\n\n英语中，可以依靠动词的变形表达多种**动词语气**。动词语气可大致分为三类：\n\n1. 陈述语气（Indicative Mood）：描述现实。\n   - I ate an apple.\n2. 祈使语气（Imperative Mood）：命令或请求。\n   - Eat the apple.\n3. 虚拟语气（Subjunctive Mood）：描述脑中的、想象中的情况。是一种描述假设或愿望、命令等内容的语气。\n   - If I saw the apple now, I would eat it.\n   - 如果我现在看见那个苹果，我会吃了它。\n\n## 虚拟语气两大用法\n\n1. 表示「不可能」假设\n2. 表达「愿望/请求/建议/命令」\n\n虚拟语气在使用时，时态要往前推一个，如表达对现在的虚拟，要用过去时；表达对过去的虚拟，要用过去完成时；表达对未来的虚拟，要用should + 动词原形。\n\n### 对「不可能」假设\n\n- 这里的「不可能」不仅仅是事实上绝对不可能，也可以表示**可能性很低**\n\n#### 与现实相反\n\n- 条件句：过去式\n- 主句：would + 动词原形\n\nIf I **were** you, I **would eat** that apple.\n如果我是你，我会吃那个苹果。（言下之意：我不是你）\n\nIf I ~~am~~ you...\n这样就变成「可能」了，但是事实上「I」不可能是「you」，所以不可以这样用\n\n#### 与将来相反\n\n- 条件句：should/were to + 动词原形\n- 主句：would + 动词原形\n\n> If I **should meet** thee after long years, how **should I greet** thee?\n> \t\t——拜伦「when we two parted」\n> 万一我们将来重逢了，我要如何面对你？（言下之意：我们相会遥遥无期）\n\n此处的should是shall的过去式\n\n主句中的would可以替换成should/could/might\n\n#### 与过去相反\n\n- 条件句：had + 动词过去分词\n- 主句：would have + 动词过去分词\n\nIf I **had ate** that apple, I **would not have been** hungry.\n如果我之前吃了那个苹果，我现在就不会饿了。（言下之意，我之前没吃苹果）\n\n### 表达「愿望/请求/建议/命令」\n\n表达希望某个事件发生，一般与表达愿望、命令的词一同使用（如wish、等）\n\n#### wish对现在的愿望\n\n- 用法：wish + 动词\n\nI wish that I **were** a cat.\n我希望我是只猫猫。\nI wish that I ~~am~~ a cat.\n\nwish后的that可以省略\n\nI wish you **were** here!\n我希望你**现在**就在这里！\n~~我希望你过去在这里！~~\n\n#### wish对过去的愿望\n\n- 用法：wish + had + 动词过去分词 或 wish + would had + 动词过去分词\n\nI wish I had eaten that apple.\n我真希望我之前吃了那个苹果。\n\n#### wish对将来的愿望\n\n- 用法：wish + should + 动词原形\n\nI wish (that) I could eat the apple.\n我希望我能吃到那个苹果。\n\n#### 其他的动词\n\n- would rather\n- demand\n- suggest\n- insist\n- order\n- ...\n\n这些动词也可以和wish一样使用\n\n### 其他从句中使用虚拟语气例\n\n- I insist that you (should) eat an apple.(宾语从句)\n- It is time that you ate the apple.(定语从句)\n- It is suggested that you (should) eat an apple.(主语从句)\n\n\n\n","tags":["语言","英语"],"categories":["语言"]},{"title":"RV-STAR开发板库函数编程——SPI通信","url":"/合集/编程/RV-STAR开发板SPI通信/","content":"\n## 本文参考资料\n\n{% note info %} \n\n- 芯来科技RVMCU官方论坛：[RVMCU课堂「15」: 手把手教你玩转RVSTAR—SPI总线通信篇__专栏_RISC-V MCU中文社区](https://www.rvmcu.com/column-topic-id-595.html)\n  - **必看教程，本文将以该示例程序作为基础作进一步解释**\n\n  \n  \n- RVSTAR开发板用户指南：[531.pdf (rvmcu.com)](https://www.rvmcu.com/uploadfile/pdf/0/0/531.pdf)\n  - 用于查看基本的GPIO复用信息。\n  \n  \n  \n- GD32VF103固件库用户指南：\n  - 用于查看库函数定义。\n  \n  \n  \n- GD32VF103中文手册：[11.pdf (rvmcu.com)](https://www.rvmcu.com/uploadfile/pdf/0/0/11.pdf)\n  - 用于查看、学习各项功能的具体实现。\n  \n  \n  \n- RVSTAR开发板原理图：[Job1 (rvmcu.com)](https://www.rvmcu.com/uploadfile/pdf/0/0/235.pdf)\n  - 最详细的引脚功能描述，可以查看到所有你需要的外设信息。例如板载LED，板载按钮的端口号和复用在开发板用户指南中并没有给出，此时需要查看原理图获取信息。\n\n\n{% endnote %}\n\n## SPI 基本原理\n\nSPI是一种串口通信协议，可以在四种模式下运行：主机发送、主机接收、从机发送、从机接收。\n\n### 通信方式概述\n\nSPI协议通信需要4根数据线，分别为：\n\n1. `MOSI - Master Output Slave Input` 主机发送，从机输入\n2. `MISO - Master Input Slave Output` 从机发送，主机输入\n3. `SCLK - Serial Clock ` 时钟信号，由**主机产生**\n4. `cs - Chip Select` 片选信号(从设备使能信号)，由**主机控制**\n\n{% note primary %} \n\nSPI通信步骤：\n\n1. 主机控制`CS`输出低电平选中特定的从机（从机只有在`CS`为低时才接收信息）\n2. 主机通过`SCLK`端口开始产生时钟信号，这个时钟信号将同时作为双发收发数据的时钟信号\n3. 主机从**主机的`MOSI`口**发出数据到从**机的`MOSI`口**\n4. 从机从**从机的`MISO`口**发出数据到**主机的`MISO`口**\n\n{% endnote %}\n\n由上述可知，`MOSI`和`MISO`口并非一定是输入或输出口，而是根据设备是主机还是从机决定的。\n\n*有时在一些设备上这些端口的名称表述上可能会有些不同，但是功能上是相同的。*\n\n{% note warning %}\n\nSPI发送没有复杂的数据格式，没有数据报头，没有数据报尾。\n如果要发送8位数据，那么发送和接收到的就是简单的8个二进制位。信息发送的同步方式由主机的使能信号和时钟信号控制。\n\n{% endnote %}  \n\n### 全双工运行模式\n\n![image-20220519180540056](image-20220519180540056.png)\n\n在全双工下，需要同时用到四根线，这也是最标准的SPI通信方式，主从双方通过上述通信步骤通信\n\n### 单工模式\n\n![image-20220519181116970](image-20220519181116970.png)\n\n![image-20220519181123484](image-20220519181123484.png)\n\n![image-20220519181133572](image-20220519181133572.png)\n\n以上各种方式都是只能单向通信，或同时只能单方发送的工作模式，在这种工作模式下只需要用到三根线，但是相比全双工模式会有一定的限制，在使用一些功能单一的从机时可能会用到。\n\n## RVSTAR的SPI发送与接收流程（只介绍主机模式）\n\n### SPI结构图\n\n![image-20220519181429590](image-20220519181429590.png)\n\n{% note info %} \n\n注意，软件应当通过读写SPI_DATA寄存器来将数据存入`发送缓冲区`和读取`接收缓冲区`，在下文中为方便理解，全部表述为「写`发送缓冲区`」和「读`接收缓冲区`」\n\n\n{% endnote %}\n\n### 主机模式发送流程\n\n初始化完成后，SPI使能模块为空闲状态。当软件写一个数据到`发送缓冲区`后，发送过程开始。\n\nSPI开始发送数据帧时，这个数据帧将加载到`移位寄存器`中，当`移位寄存器`中的**第一个位（bit）**发出后，TBE（发送缓冲区空信号）位置1。**TBE置1说明`发送缓冲区`为空**，如果还要继续发送数据，则此时可以向`发送缓冲区`写数据。\n\n### 主机接收流程\n\n在最后一个采样时钟边沿后，接收到的数据从`移位寄存器`存入到`接收缓冲区`，且RBNE（接收缓冲区非空）位置1。RBNE置1说明`接收缓冲区`满，软件可以通过读`接收缓冲区`读取接收到的数据，**当软件读取接收缓冲区时，会自动清除RBNE标志位**。\n\n{% note error %} \n\n**在全双工主机模式下，仅当`发送缓冲区`非空时，硬件才接收下一个数据帧。**\n\n注意上文这段话非常重要，意思是说SPI在全双工通信时，如果想要接收信息，必须要让**`发送缓冲区`**非空！\n如果在后续写程序的时候没有注意这一点会导致读取异常，这一点在官方的示例程序中没有展示，也没有提及。\n\n\n{% endnote %}\n\n### 主机收发流程总结\n\n主机发送信息且不需要接收回复时：\n\n1. 检查TBE，等待其为1\n2. 数据写入`发送缓冲区`\n3. 等待RBNE为1\n4. 读`接收缓冲区`以清空RBNE标志位\n\n主机发送信息且需要接收回复时：\n\n1. 检查TBE，等待其为1\n2. 数据写入`发送缓冲区`\n3. 等待RBNE为1\n4. 读`接收缓冲区`以清空RBNE标志位\n5. **把一个废数据（或者对从机来说是空指令的数据，一般为0x0）写入`发送缓冲区`**\n6. **等待RBNE为1**\n7. **读`接收缓冲区`以获得返回数据**\n\n注意主机发送一条消息后，如果还要获得回复，那么必须要再写入一条废数据（空指令）来让`发送缓冲区`非空，从而让硬件能接收返回的数据帧。\n\n## RVSTAR使用SPI编程实现\n\n首先说明，SPI并非很复杂的通信协议，所以在掌握了上文描述的SPI通信原理后，完全可以通过简单地GPIO手动控制时钟翻转和数据输入输出，但是这里介绍由芯片提供的SPI功能实现。\n\n### 外设配置\n\n首先对SPI外设进行配置：\n\n1. 开启GPIO时钟\n2. 开启外设时钟复用\n3. 开启SPI时钟\n4. GPIO初始化为复用模式\n\n查阅手册可知PA5/PA6/PA7可以复用为SPI功能\n\n![image-20220519202439254](image-20220519202439254.png)\n\n```c\n    rcu_periph_clock_enable(RCU_GPIOA); // GPIOA时钟\n    rcu_periph_clock_enable(RCU_AF); // 复用时钟\n    rcu_periph_clock_enable(RCU_SPI0); // SPI0时钟\n\t\n\t// PA5和PA7作为输出口，设置为O推挽复用输出\n    gpio_init(GPIOA, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_5 | GPIO_PIN_7);\n\t// PA6作为主机输入，设置为浮空模式\n    gpio_init(GPIOA, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_6);\n```\n\n### SPI配置\n\nSPI配置主要是要配合从机的工作方式，例如从机的信号读取边沿、从机能接受的信息传输速率、从机的大小端接收方式等等。其配置方式由结构体`spi_parameter_struct`决定，其属性如下：\n\n![image-20220519203017685](image-20220519203017685.png)\n\n这里解释几个比较不好理解的参数：\n\n- frame_size\n  - 数据帧格式，可以为8或16。注意到芯片提供的SPI移位寄存器和输入输出缓冲区都是16位的，如果我们要发送8位的数据，有些人可能会担心是否需要在程序里对数据进行处理，以适配16位。答案是不需要，只要在数据帧格式里设置完成后就不需要程序员再去关心这个了。\n- nss\n  - nss就是上文提到的cs从机片选，软件模式指由程序员手动控制GPIO，或直接拉低来控制从机的cs；硬件模式则是在发送时由硬件自动控制片选信号。软件模式的好处是可以由一组SPI连接多个从机，通过软件片选来选择从机。详细见文档。\n- clock_polarity_phase\n  - ![image-20220519203807731](image-20220519203807731.png)\n    可参考：[SPI相位跟极性介绍_Fields_Of_Gold的博客-CSDN博客_spi相位和极性](https://blog.csdn.net/liu__ke/article/details/17526087)\n- endian\n  - 注意这里指的是移位寄存器先发送高位（MSB）还是低位(LSB)，如果从机希望接收到的第一个bit是高位，那就选择MSB，否则选择LSB\n\n```c\n\tspi_struct_para_init(&spi_init_struct); // 库函数中的结构体初始化函数\n\n    spi_init_struct.trans_mode = SPI_TRANSMODE_FULLDUPLEX; // 全双工模式\n    spi_init_struct.device_mode = SPI_MASTER; // 主机模式\n    spi_init_struct.frame_size = SPI_FRAMESIZE_8BIT; // 1个数据帧大小为8bit\n\n\t// 初始时钟为低，且第一个边沿有效上升沿有效。即上升沿有效\n    spi_init_struct.clock_polarity_phase = SPI_CK_PL_LOW_PH_1EDGE; \n\n    spi_init_struct.nss = SPI_NSS_SOFT; // 软件模式\n    spi_init_struct.prescale = SPI_PSC_128; // SPI分频，控制发送速率\n    spi_init_struct.endian = SPI_ENDIAN_MSB; // 高位先发\n    spi_init(SPI0, &spi_init_struct); // 将SPI配置结构体送入初始化函数\n```\n\n### 完整SPI初始化\n\n```c\nvoid spi_config()\n{\n    rcu_periph_clock_enable(RCU_GPIOA);\n    rcu_periph_clock_enable(RCU_AF);\n    rcu_periph_clock_enable(RCU_SPI0);\n\n    /* configure SPI0 GPIO : SCK/PA5, MISO/PA6, MOSI/PA7 */\n    gpio_init(GPIOA, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_5 | GPIO_PIN_7);\n    gpio_init(GPIOA, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_6);\n\n    spi_parameter_struct spi_init_struct;\n    /* deinitialize SPI and the parameters */\n    spi_i2s_deinit(SPI0);\n    \n    spi_struct_para_init(&spi_init_struct);\n    /* configure SPI0 parameters */\n    spi_init_struct.trans_mode = SPI_TRANSMODE_FULLDUPLEX;\n    spi_init_struct.device_mode = SPI_MASTER;\n    spi_init_struct.frame_size = SPI_FRAMESIZE_8BIT;\n    spi_init_struct.clock_polarity_phase = SPI_CK_PL_LOW_PH_1EDGE;\n    spi_init_struct.nss = SPI_NSS_SOFT;\n    spi_init_struct.prescale = SPI_PSC_128;\n    spi_init_struct.endian = SPI_ENDIAN_MSB;\n    spi_init(SPI0, &spi_init_struct);\n}\n```\n\n### 使用SPI发送且不接收回复\n\n```c\nint main()\n{\n    /* configure SPI */\n    spi_config();\n    /* SPI enable */\n    spi_enable(SPI0);\n\n    while (1)\n    {\n        char c;\n        for (const char *p = \"Hello World\\n\\r\"; c = *p; p++)\n        {\n            while(RESET == spi_i2s_flag_get(SPI0, SPI_FLAG_TBE));\n            spi_i2s_data_transmit(SPI0, c);\n            while(RESET == spi_i2s_flag_get(SPI0, SPI_FLAG_RBNE));\n            spi_i2s_data_receive(SPI0);// 读缓冲，重置缓冲区满信号，例程中没有这一句，很不好，应当将缓冲区满信号清空\n        }\n        delay_1ms(2000);\n    }\n}\n```\n\n### 使用SPI发送且接收回复\n\n```c\n// msg: 向从机发送的消息\nuint8_t read_data(uint8_t msg)\n{\n    gpio_bit_reset(GPIOA, NSS); // 片选开（如果有片选的话）\n\n    /*  准备发送消息  */\n    while (RESET == spi_i2s_flag_get(SPI0, SPI_FLAG_TBE))// 等待输入缓冲空\n        ;   \n    spi_i2s_data_transmit(SPI0, msg); // 发送消息\n    while (RESET == spi_i2s_flag_get(SPI0, SPI_FLAG_RBNE))// 等待读取缓冲满\n        ;\n    spi_i2s_data_receive(SPI0); // 读缓冲，重置缓冲区满信号\n    \n    /*  再发送一个空地址\n        RVSTAR要求发送缓冲区不为空才能读取\n        如果不发送，则无法正常读取  */\n    while (RESET == spi_i2s_flag_get(SPI0, SPI_FLAG_TBE))// 等待输入缓冲空\n        ;\n    spi_i2s_data_transmit(SPI1, 0); // 向发送缓冲区输入一个数据\n    while (RESET == spi_i2s_flag_get(SPI1, SPI_FLAG_RBNE))// 等待读取缓冲满\n        ;\n    uint16_t receive_data;\n    receive_data = spi_i2s_data_receive(SPI1); // 读缓冲，重置缓冲区满信号\n    gpio_bit_set(GPIOA, NSS); // 片选关（如果有片选的话）\n    return receive_data;\n}\n```\n\n上面是一个「发一个，收一个」的示例，可以看到如果要收一个数据发送缓冲区里要有数据。\n也就是说如果你要实现「发n个，收n个」，那么**在第k个数据发送时，你也可以同时接收到第k-1个数据的返回**，而且在第n个数据发送的同时可以接收到从机第n-1个的返回，所以最后还得在补发一个废数据以接收从机的第n个返回。\n\n## 结(Tu)语(Cao)\n\n最为嵌入式初学者，使用了较新的国产开发板RVSTAR入门，本身相关的例程就几乎没有，而且官方的SPI示例代码中还出现了SPI全双工只演示发送不演示接收的情况，甚至在不清空缓冲区标志位的情况下还去读缓冲区标志位的不良操作。这些情况结合起来导致我在处理SPI通信——尤其是SPI接收——时走了不少弯路。\n\n","tags":["编程","技术","嵌入式"],"categories":["编程"]},{"title":"2021.10动画推荐","url":"/合集/动画推荐/2021_10 动画推荐/","content":"\n{% note warning %} \n\n**主观判断警告**!\n\n本文纯粹出于笔者个人主观经验与感受而成，如有任何不同意见欢迎友善交流讨论\n\n没有提到的作品笔者没看，或不符合笔者个人兴趣，或观看价值较低\n\n另外，本文不提供动画简介，对感兴趣的动画可以点击「更多信息」访问[Bangumi 番组计划](https://bangumi.tv/)网站的详情页面\n\n{% endnote %}\n\n## 月とライカと吸血姫（月与莱卡与吸血公主）\n\n![330918_bDbb1](330918_bDbb1.jpg)\n\n推荐度：90分\n\n在美苏太空竞赛的背景下，苏联希望完成首例载人航天飞行。为保证首位航天员的安全，苏联找来了吸血鬼伊琳娜作为实验体进行试飞。伊琳娜在自己知道自己是实验体，且实验完成后就会被废弃的前提下，资源参与航天计划，只因她向往宇宙，向往月球。伊琳娜的监视人列夫与伊琳娜一样，对宇宙有着无穷的念想，二人一起以宇宙为目标前进。\n\n精致的画面，细腻的剧情，让人深深感到宇宙的浪漫、人类探索自然的热情，对人物的情感变化也有很深的刻画。\n\n剧情较为平淡，但是意境很美，值得一看。\n\n京都出品，必属精品。同第一季一样，依然是温馨轻松的日常动画，画风清新精致，剧情轻松活泼，适合日常萌系爱好者。\n\n更多信息：[月とライカと吸血姫 | Bangumi 番组计划](https://bangumi.tv/subject/330918)\n\n关键词：`科幻`，`奇幻`，`治愈`，`林原惠美`，`苏联`\n\n## 先輩がうざい後輩の話（关于前辈很烦人的事）\n\n![309670_SCMw3](309670_SCMw3.jpg)\n\n推荐度：85分\n\n萝莉身材的五十岚双叶和巨人体型武田晴海的职场恋爱喜剧。\n\n经典的笨拙男主+迟钝女主的设定，剧情轻松简单，值得一看。\n\n更多信息：[先輩がうざい後輩の話 | Bangumi 番组计划](https://bangumi.tv/subject/309670)\n\n关键词：`恋爱`，`职场`，`喜剧`，`合法萝莉`\n\n## 世界最高の暗殺者、異世界貴族に転生する（世界顶尖的暗杀者转生为异世界贵族）\n\n![328313_oQlyW](328313_oQlyW.jpg)\n\n推荐度：75分\n\n男主前世是暗杀者，死后被女神拉去异世界暗杀勇者。男主利用前世知识在异世界大杀四方，典型的龙傲天后宫作品，不需要带脑子看男主装x就好了。\n\n更多信息：[世界最高の暗殺者、異世界貴族に転生する | Bangumi 番组计划](https://bangumi.tv/subject/328313)\n\n关键词：`龙傲天`，`异世界`，`穿越`，`后宫`\n\n## 大正オトメ御伽話（大正处女御伽话）\n\n![323158_MbmZ4](323158_MbmZ4.jpg)\n\n推荐度：65分\n\n男主失去一条手臂而自闭，被家里扔到一栋别墅里，还配了个老婆。男主衣食无忧还天降一个温柔体贴的老婆，还整天苦大仇深，对我来说既不能理解男主的抑郁，也不能理解女主对男主的死心塌地。忽略这些问题勉强能看。\n\n更多信息：[大正オトメ御伽話 | Bangumi 番组计划](https://bangumi.tv/subject/323158)\n\n关键词：`恋爱`，`日常`，`幼妻`\n\n## 最果てのパラディン（世界尽头的圣骑士）\n\n![333442_rkukV](333442_rkukV.jpg)\n\n推荐度：60分\n\n被三名古代英雄在远离人世的环境中抚养长大的男主，为了战胜邪恶之神与不死族而踏上圣骑士之旅。男主是典型的龙傲天，但是剧情过于拖沓，让人看着很不爽。男主作为异世界转生者，就仅仅只是个设定，这个身份在剧情中没有起到哪怕一点用（仅讨论动画），而且男主作为由英雄培养出的龙傲天角色，在如此拖沓的剧情下竟然也不能让观众感到爽，让我很失望。打斗、人物塑造、台词都过于平庸。念在设定上还算不错，勉强给个及格分。\n\n据说原作小说写得还行，看动画中出现有大量的内心独白，或许原作的文字叙述比动画有更好的表现力。\n\n更多信息：[最果てのパラディン | Bangumi 番组计划](https://bangumi.tv/subject/333442)\n\n关键词：\n\n## 86―エイティシックス― 第2クール（86不存在的战区 第二季）\n\n![331887_rZdb9](331887_rZdb9.jpg)\n\n推荐度：??分\n\n本作难以给出评分，对86的评价褒贬不一，有人觉得它是神作，为了第二季最后一集就值得把第一季补了；也有人觉得86的整个世界观就是个笑话，作者不懂装懂，无病呻吟。\n\n在我看来，不去考虑剧中政治、军事、种族歧视等种种不合理的要素，那么其实可以单纯将其看做是Boy Meets Girl的经典剧情。一个是所谓的「高阶人种」的女主，另一个是受歧视的冷酷士兵男主，女主反对国家对人种的歧视踏上了追寻男主的旅途，最终二人面对面相遇。\n\n不要去考虑那些不合理的设定，就当做网恋奔现来看，第二季作为第一季的后续还是挺不错的。\n\n更多信息：[86―エイティシックス― 第2クール | Bangumi 番组计划](https://bangumi.tv/subject/331887)\n\n关键词：`机战`，`恋爱`","tags":["二次元","动画"],"categories":["动画推荐"]},{"title":"Windows原理与应用（四）——动态链接库","url":"/合集/Windows原理与应用/Windows原理与应用（四）——动态链接库/","content":"\n# 动态链接库（Dynamic Link Library）\n\n## 关于动态链接库\n\n### 链接\n\n大多数高级语言都支持分别编译（compiling），程序员可以显式地把程序划分为独立的模块或文件，然后由编译器（compiler）对每个独立部分分别进行编译。在编译之后，由链接器（Linker）把这些独立编译单元链接（Linking）到一起\n\n### 静态链接\n\n在程序开发中，将各种目标模块（.OBJ）文件、运行时库（.LIB）文件，以及已编译的资源（.RES）文件链接在一起，以便创建Windows的.EXE文件，这种方式是静态链接\n\n### 动态链接\n\n在程序运行时，Windows把一个模块中的函数调用链接到库模块中的实际函数上的过程\n\n### 二者区别\n\n- 静态链接会将相关的程序全部打包到最终的可执行文件中\n- 静态链接不会将程序打包到可执行文件中，而是在.exe执行时调用独立的.dll文件\n\n## dll地狱\n\n- dll地狱指因为系统文件被覆盖而让整个系统崩溃的现象\n- 例如多个系统程序依赖某个dll模块，而又有一些程序依赖该dll模块的新版本，而这个dll模块的新版本又不向下兼容，那么当你更新该dll模块后，则多个系统程序将无法工作\n- .Net平台中允许一个dll的多个版本同时在同一台机器上工作，从而解决了这一问题，该技术成为`Side-by-Side`[^1]\n\n## Windows中主要的dll\n\n| 名称         | 功能                                                         |\n| ------------ | ------------------------------------------------------------ |\n| KERNEL32.DLL | 低级内核函数，用于内存管理、任务管理、资源控制等             |\n| USER32.DLL   | windows管理有关的函数，消息、菜单、光标、计时器、通信，钩子等 |\n| GDI32.DLL    | 图形设备接口库                                               |\n| ODBC32.DLL   | ODBC功能                                                     |\n| Ws2_32.dll   | socket通信功能                                               |\n\n## dll中函数输入/输出参数（c#）\n\n- 传值\n- ref\n- out\n\n其中，ref和out类似，但是ref需要自己赋初值，而out由dll负责赋值\n\n## dll的引用计数\n\n- DLL在内存中只有一个实例，系统为每个DLL维护一个线程级的引用计数，一旦一个线程载入了该DLL，引用计数将会加1。而程序终止或者引用计数变为0（仅指运行时动态链接库），DLL就会释放占用程序的虚地址空间。\n\n## Windows的虚地址映射\n\n- Windows将提供内部的地址映的工作，例如一个DLL文件被加载后在物理内存中**只占一个固定区域**，有多个进程使用同一个DLL文件，Windows将这个DLL的内存地址空间通过地址映射后提供给各个进程，进程代码地址与DLL映射后地址构成的是进程的虑地址空间，进程在自己的虚地址空间中好像是自己独自在使用这个DLL文件，使用DLL中的函数与程序自身的函数没有区别。\n\n## C#创建DLL类库（托管的动态链接库）\n\n- 一个没有main的.cs文件生成为dll\n\n```csharp\nnamespace csTestDLL\n{\n    public class csDLLClass\n    {\n        double Pie = Math.PI;\n\n        public double PIE { get => Pie;}\n\n        public string say_hello()\n        {\n            return \"Hello! This is csTestDLL.\";\n        }\n\n        private double calc_power_two(double r)\n        {\n            return r * r;\n        }\n\n        public double calculate_circle_area(double r)\n        {\n            return Math.PI * calc_power_two(r);\n        }\n    }\n}\n```\n\n- 调用这个dll\n\n![image-20211207153830827](image-20211207153830827.png)\n\n```csharp\nAssembly csdll = Assembly.LoadFrom(\"csTestDLL.dll\"); // 装载dll\n\npublic void say_hello_cs()\n{\n    // 通过反射获取类型、函数、变量\n    foreach (Type t in csdll.GetTypes())\n    {\n        if (t.IsClass && !t.IsAbstract)\n        {\n            ConstructorInfo[] ci = t.GetConstructors(); // 获取构造列表\n            MethodInfo[] mis = t.GetMethods();// 获取函数列表\n            callback(\"构造函数：\" + ci[0].ToString(), listname);\n            foreach (var item in mis)\n            {\n                callback(\"pulic函数：\" + item.ToString(), listname);\n            }\n            mis = t.GetMethods(BindingFlags.NonPublic | BindingFlags.Instance); // 一定要两个bindingflags同时有才能获取私有函数\n            foreach (var item in mis)\n            {\n                callback(\"private函数：\" + item.ToString(), listname);\n            }\n            MethodInfo mi = t.GetMethod(\"say_hello\"); // 调用say_hello函数\n            object obj = Activator.CreateInstance(t); // 创建实例\n            // Object obj = Activator.CreateInstance(typeof(String),new Object[] {13, 10 } );\n            // 有参构造的情况↑\n            \n            string msg = mi.Invoke(obj, null) as String;\n            callback(\"welcome：\" + msg, listname);\n            callback(split_line, listname);\n        }\n    }\n}\n```\n\n```csharp\npublic void calc_circle_area(double r = 1)\n{\n    foreach (Type t in csdll.GetTypes())\n    {\n        if (t.IsClass && !t.IsAbstract)\n        {\n            Type[] p = new Type[0]; // 无参构造\n            ConstructorInfo ci = t.GetConstructor(p); // 获取构造\n            object o = ci.Invoke(null); // 调用构造，和Activator.CreateInstance(t)效果是一样的\n            MethodInfo mi = t.GetMethod(\"calculate_circle_area\"); // 获取计算面积函数\n            object[] para = new object[1] { r };\n            string msg = mi.Invoke(o, para).ToString();\n            callback(\"圆面积：\" + msg, listname);\n            callback(split_line, listname);\n        }\n    }\n}\n```\n\n![image-20211207155521779](image-20211207155521779.png)\n\n## C++非托管动态链接库\n\n### 头文件类型\n\n```cpp\n#include \"myHead.h\"\n#include \"pch.h\"\n\n\n// 有def就不必写头文件了，没有def必须定义头文件，或者将导出定义在函数名上 -> \n// extern \"C\" __declspec(dllexport) int __stdcall factorial(int n)\n// 必须有__stdcall，否则调用报错\n\n\nint __stdcall factorial(int n) {\n    int ans = 1;\n    while (n > 1) {\n        ans *= n;\n        n--;\n    }\n    return ans;\n}\n```\n\n- **关于__stdcall**[^2]\n  - __stdcall是微软特有的修饰符\n  - 它表示对这个程序要按照约定的方式调用，会将所有函数当做winapi调用\n\n\n\n\n```cpp\n#pragma once\n\n// 只是定义一个头并没有用，因为除了C/C++调用外，这个头并不会被编译\n// 要将它放到pch.h头中才会编译\n\n// __declspec(dllexport)声明导出函数\n// extern \"C\" 用于非C/C++调用\nextern \"C\" __declspec(dllexport) int __stdcall factorial(int n);\n```\n\n- 调用\n\n```cpp\n/// <summary>\n/// 自建cpp动态库\n/// </summary>\n[DllImport(\"../../../debug/cppTestDLL.dll\")]\nprivate static extern Int32 factorial(int n);\n\n\n/// <summary>\n/// c++动态库\n/// </summary>\n/// <param name=\"num\"></param>\npublic void calc_factoria(int num)\n{\n    callback(\"cppDLL开始调用\", listname);\n    Int32 ans = factorial(num);\n    callback(num + \"! = \" + ans.ToString(), listname);\n    callback(split_line, listname);\n}\n```\n\n### 使用def\n\n```\nLIBRARY library\n\n\nEXPORTS\nfactorial\n```\n\n### 注意\n\n```csharp\n[ DllImport( \"kernel32.dll\",EntryPoint=\"GetVersionEx\" )] \n// your func name...\n\n// 这种写法定义了EntryPoint，这样写的作用是可以自定义函数名\n// 如果不写EntryPoint，则调用时的函数名必须为「GetVersionEx」\n```\n\n[^1]:[ASP.NET 并行 (Side-by-Side) 概述](https://docs.microsoft.com/zh-cn/previous-versions/visualstudio/visual-studio-2008/a99txfy5(v=vs.90))\n\n[^2]:[__stdcall | Microsoft Docs](https://docs.microsoft.com/en-us/cpp/cpp/stdcall?redirectedfrom=MSDN&view=msvc-170)","tags":["编程","技术"],"categories":["Windows原理与应用"]},{"title":"ATRI -My Dear Moments-","url":"/ATRI/","content":"\n# ATRI -My Dear Moments-\n\n> ~~HE初通记~~\n>\n> TE也通了\n\n{% note warning %}\n\n## 剧透警告！\n\n本文包含对剧情的描述\n\n## CG出现警告！\n\n本文包含游戏CG\n\n{% endnote %}  \n\n- 更：TE也通了，最后机械飞升能和亚托莉在一起挺好，只是水彩萌有点惨\n\n***\n\n![atri](atri.jpg)\n\n<!--more-->\n\n## 整体感受\n\n- 剧情：8/10\n\n  - 中规中矩的故事，节奏控制合理，没有大段的流水账（此处@三色绘恋）。前半段亚托莉伪装的感情拯救了夏生，而当夏生发现亚托莉的伪装后依然决定履行之前的承诺，拯救亚托莉，最后也终于让亚托莉认识到自己的感情。虽然亚托莉在自己真实的感情下与夏生相处的时间只有短短4天，但这段感情难道就没有意义了吗？当然不是。这在剧情中也给出了相应的思考。\n\n- 人设：8.5/10\n\n  - 亚托莉从「活泼的战斗机器人」到只是模拟情感的无情机器，再到早已遍体鳞伤却浑然不知的柔弱少女。这一系列的反转冲击，又有几个阿宅把持得住呢。\n  - 夏生，男主角，高颜值高智商，但是家庭破碎，有心理创伤。小时候由于车祸失去母亲，又落得腿部残疾。在男主童年最绝望的时候，是亚托莉给了他生活的目标；在男主将遭遇危险时，是亚托莉暗中保护她；现在男主从研究院落魄而归，又是亚托莉让他重拾生活的希望。而当男主发现亚托莉在模拟人的情感时，他并没有因被骗的失望而大发雷霆，而是进一步了解亚托莉，最终让亚托莉认识到了感情。\n  - 其他配角也有鲜明的特点，并没有着重展开，详略得当。只是作为唯一的反派，实属为反而反了，我觉得有点突兀。\n\n- 美术：9.5/10\n\n  - 差0.5分怕制作方骄傲。\n  - 首先是亚托莉，外表是浅色柔顺的长发，红色的瞳孔，身着轻飘飘的白色水手服，有着十几岁少女的样貌和身材。从外观上来看便是能够激起保护欲的可爱清纯少女。\n\n  ![亚托莉jpg](亚托莉jpg.jpg)\n  - 然后是夏生，夏生有着高冷帅气的面容，身材高挑，一眼便给人一种沉着冷静，足智多谋的形象。给观众良好的体验。\n\n  ![夏生](夏生.jpg)\n\n  - 最后是场景美术，场景绘制也相当不错，但是主要的表现重心还是人物，场景相当不错但并不比角色惊艳。\n\n  ![scene1](scene1.jpg)\n\n  ![scene2](scene2.jpg)\n\n## 关于机器人情感的一点思考\n\n关于思考有一个重要的矛盾点在于机器人的感情。机器人到底能否拥有可以被普遍人类承认的意识与感情？这个问题恐怕大多数人都难以回答，因为人类对于意识和感情的定义本就相当模糊不清。\n\n马克思是这样定义意识的本质的：\n\n> 意识是人脑特有的机能，是人脑对客观事物的主观反映。\n\n这句话让几乎所有的中国思政老师都要强调，只有人脑才能有意识。但是为什么是人脑，人脑是什么特殊的存在吗？如果有能够和人脑一样复杂的机器存在，这台机器产生的思考难道不能被称为「意识」吗？\n\n所以我认为，所谓意识要存在必须具备两个条件：\n\n1. 足够复杂、高级的物质基础，例如人脑，或是高度复杂先进的机器\n2. 通过客观世界的学习转化而来\n\n亚托莉在没有意识到自己的感情时所「伪装」出来的活泼性格，这是真实的情感吗，是亚托莉的**意识**所衍生出的情感吗？在剧情中，水菜萌已经给出了她的答案，她认为这些情感也是真实的情感，因为这些情感是亚托莉对客观世界的学习而产生的对客观世界的基本认识。在这层意义上，我赞同水菜萌的观点，**我认为这些情感也是亚托莉的情感——只不过亚托莉自己没有意识到这一点，并不断以冷酷的视角去审视这些情感。**\n\n## 总结\n\n优秀的立绘，优秀的人设，优秀的配乐，优秀的配音，扎实的剧情。非常值得一玩的全年龄视觉小说。\n\n","tags":["二次元","游戏"],"categories":["其他"]},{"title":"关于歌曲「星の世界」","url":"/合集/生活/星の世界/","content":"\n# 关于歌曲「星の世界」\n\n## 星の世界\n\n「星の世界」，看名字就知道是一首日文歌曲，但是在中国，它也是一首耳熟能详的ACG名曲。\n\n相信很多人第一次听到「星の世界」应该是在星之梦([星之梦 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/星之夢))，开篇祥和神圣的八音盒音乐，再加上星野梦美温柔的旁白，肯定在各位的心中留下了深刻的映像。\n\n这首美丽的曲子成了星之梦的标志，但事实上，这首曲子并非星之梦原创，它早在19世纪就已经诞生了。\n<!--more-->\n\n## 星の界（よ）\n\n「What a Friend We Have in Jesus」[^1]是一首基督教的赞美歌，诗词在1855年作成，而曲调于1868年作成，它的曲调便是「星の世界」的起源。\n\n后来这首歌传到日本，被改为「いつくしみ深き」（大意为「深沉的慈爱」），作为日本的基督教赞美歌，它也成为了教会中经常在结婚时播放的赞美歌之一。[^2]\n\n1910年（明治43年），文部省将其重新填词为「星の界（よ）」。这时，这首歌便进一步走向民众。由「いつくしみ深き」改编填词的「星の界」或者「星の世界」版本有很多。其中最早的「星の界」的填词者是杉谷代水，也就是下方给出的版本。[^3]\n\n> 月なきみ空に　きらめく光\n> 嗚呼(ああ)その星影(ほしかげ)　希望のすがた\n> 人智(じんち)は果てなし　無窮(むきゅう)の遠(おち)に\n> いざその星影　きわめも行かん\n>\n> 雲なきみ空に　横とう光\n> 嗚呼洋々(ようよう)たる　銀河の流れ\n> 仰(あお)ぎて眺(なが)むる　万里のあなた\n> いざ棹(さお)させよや　窮理(きゅうり)の船に\n\n歌词大意：\n\n> 在没有月亮的天空中  闪烁着淡淡的光\n> 啊啊  这星星的光芒  是希望的身影\n> 人类的智慧没有尽头  通向无穷的远方\n> 去探寻那未知的星光吧\n>\n> 在没有云朵的天空中  流淌着光芒\n> 啊啊  像是要满溢出来的  是银河在奔流\n> 抬头远眺  朝着你离开的方向\n> 一起划着真理之船前进吧\n\n\n由于含歌词的「What a Friend We Have in Jesus」不能由链接播放，所以这里就只放纯音乐版的\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=21264810&auto=0&height=66\"></iframe>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=1453011471&auto=0&height=66\"></iframe>\n\n\n\n[^1]: [What a Friend We Have in Jesus - Wikipedia](https://en.wikipedia.org/wiki/What_a_Friend_We_Have_in_Jesus#:~:text=What%20a%20Friend%20We%20Have%20in%20Jesus%20Fra,fikk%20f%C3%B8rst%20full%20kreditering%20for%20det%20i%201880-%C3%A5rene.)\n[^2]: [いつくしみ深き 歌詞の意味 賛美歌 (worldfolksong.com)](http://www.worldfolksong.com/hymn/friend-jesus.html)\n[^3]: [[星の世界（星の界）歌詞の意味 音楽教科書の歌 (worldfolksong.com)](http://www.worldfolksong.com/hymn/hoshino-sekai.html)","tags":["科普","音乐"],"categories":["生活"]},{"title":"Windows原理与应用（三）——线程间通信与同步","url":"/合集/Windows原理与应用/Windows原理与应用（三）——线程间通信与同步/","content":"# Windows原理与应用（三）——线程间通信与同步\n\n{% note info %} \n\n## 系列\n\n[Windows原理与应用（一）—— 简介 | 德依安-BLOG (ddg-302.github.io)](https://ddg-302.github.io/合集/Windows原理与应用/Windows原理与应用（一）/)\n\n[Windows原理与应用（二）——程序进程与进程间通信 | 德依安-BLOG (ddg-302.github.io)](https://ddg-302.github.io/合集/Windows原理与应用/Windows原理与应用（二）——程序进程与进程间通信/)\n\n<p style=\"color:grey\">[本文]Windows原理与应用（三）——线程间通信与同步 | 德依安-BLOG(ddg-302.github.io)</p>\n\n{% endnote %}\n\n## 线程\n\n- 进程是计算机分配资源的单位，线程是运行调度单位\n- 进程中的线程也具有线程控制块，包含内容有所属进程ID，创建和退出时间，线程启动地址等\n\n### 线程创建过程\n\n1. 在进程的地址空间中为线程创建用户态堆栈。\n2. 初始化线程硬件上下文。\n3. 创建线程对象。\n4. 通知内核系统为线程运行准备。\n5. 新创建线程handle和线程ID值返回到调用者。\n6. 线程进入调度准备执行。\n\n## 线程的生命周期\n\n启动→执行→暂停→终止\n\n## 工作线程的结束\n\n- 线程正常结束\n  - 自动消亡，OS清理\n- 线程非正常结束，被KILL\n  - OS无法控制，造成系统损失或破坏\n- 控制线程正常终止的方法\n  - 低级事件对象ManualResetEvent\n\n### 线程非正常结束的后果\n\n- 内存无法回收 - 内存泄漏\n- 文件缓冲没写入 - 文件被破坏\n- 文件句柄未回收 - 被占用\n- 共享资源的占用(网络端口，管道，DLL)\n\n## 线程的创建与启动 - C#\n\n### 多线程与线程跨域访问\n\nWindows中每个进程都至少有一个线程，称为主线程，对于通常的窗体应用，主线程与窗体界面绑定\n如果有耗时很长的处理函数在主线程中运行，会导致界面停滞，失去响应，所以需要把工作交给工作线程执行，执行结束后将结果通知给界面线程\n\n处于安全性考虑，不同线程之间不可以相互调用对方的资源，即**不允许直接跨域访问**，需要使用委托回调的方式调用\n\n```csharp\npublic class Work\n{\n    // 回调委托声明\n    public delegate void update_listbox(string new_info, string listname);\n    update_listbox callback; // 一个具体的委托\n    string list_name;\n    public Work(update_listbox callback, string list_name)\n    {\n        this.callback = callback; // 具体委托绑定另一个线程中的函数\n        this.list_name = list_name;\n    }\n}\n\n// 主窗体函数\nprivate void update_output(string new_info, string list_name)\n{\n    // 同步方法\n    Dispatcher.Invoke(() =>\n    {\n        // 主窗体用Invoke同步线程更新控件\n        ListBox lb = FindName(list_name) as ListBox;\n        ListBoxItem li = new ListBoxItem();\n        li.Content = new_info;\n        lb.Items.Add(li);\n    });\n    \n    // 异步方法\n    //Action actiondelegate = () =>\n//{\n//    try\n//    {\n//        ListBox lb = FindName(list_name) as ListBox;\n//        //update_dele test = update_work_listbox;\n//        update_work_listbox(new_info, lb);\n//    }\n//    catch (Exception e)\n//    {\n//        MessageBox.Show(\"发生错误：\" + e.Message, \"错误\", MessageBoxButton.OK, MessageBoxImage.Error);\n//    }\n//};\n//Dispatcher.BeginInvoke(actiondelegate);\n//    // 主窗体用BeginInvoke异步线程更新控件\n//    }\n    \n// 传入函数\nWork wk = new Work(update_output, \"listname\");\n```\n\n\n\n### 异步线程\n\n#### Thread\n\n1. 不含参数的构造\n\n```csharp\nusing System.Threading;\n\n// 线程执行函数\nvoid workThread(){\n    // to do\n}\n\n// 设定函数名为线程入口\nThreadStart s = new ThreadStart(workThread);\n\n// 线程委托对象\nThread thread1 = new Thread(s);\nthread.Name = \"设定一个名称\"; // 可以设定名称\nthread.IsBackground = true; // 可以设定是否为后台\n// 启动线程\nthread1.Start();\n// 启动含有参数的线程\nthread1.Start(paraObject);\n```\n\n```csharp\n// 也可以使用匿名委托或lambda表达式\n//通过Lambda表达式创建\nThread thread1 = new Thread(() => Console.WriteLine(\"我是通过Lambda表达式创建的委托\"));\nthread1.Start();\n\n//通过匿名委托创建\nThread thread2 = new Thread(delegate() { Console.WriteLine(\"我是通过匿名委托创建的线程\"); });\nthread2.Start();\n\n\n```\n2. 含参数的构造\n\n```csharp\n// 含有参数的Thread\n//通过ParameterizedThreadStart创建线程\nThread thread = new Thread(new ParameterizedThreadStart(Thread1));\n//给方法传值\nthread.Start(\"这是一个有参数的委托\");\n\n\n// 创建有参的方法，方法里面的参数类型必须是Object类型\nvoid Thread1(object obj){\n\tConsole.WriteLine(obj);\n}\n```\n\n- Thread默认只有这两种构造方式，如果要传入多个参数，需要用类来实现\n\n操作Thread的常用函数\n\n| 方法名称      | 说明                                                 |\n| ------------- | ---------------------------------------------------- |\n| Abort()       | 终止本线程                                           |\n| GetDomain()   | 返回当前线程正在其中运行的当前域                     |\n| GetDomainId() | 返回当前线程正在其中运行的当前域Id                   |\n| Interrupt()   | 中断处于Wait Sleep Join线程状态的线程                |\n| Join()        | 阻塞调用线程，直到某个线程终止时为止                 |\n| Resume()      | 继续运行已挂起的线程                                 |\n| Start()       | 执行本线程                                           |\n| Suspend()     | 挂起当前线程，如果当前线程已属于挂起状态则此不起作用 |\n| Sleep()       | 把正在运行的线程挂起一段时间                         |\n\nThread的常用属性\n\n| 属性名       | 说明                                   |\n| ------------ | -------------------------------------- |\n| IsAlive      | 获取一个值，表示当前线程的执行状态     |\n| Name         | 获取或设置Thread的名称                 |\n| ThreadState  | 获取一个值，表示当前线程的状态         |\n| IsBackground | 获取一个值，指示当前线程是否为后台线程 |\n\n{% note info %} \n\nThread详细信息：[Thread 类 (System.Threading) | Microsoft Docs](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.thread?view=netframework-4.8)\n\n{% endnote %}\n\n#### Task\n\n- 无返回值的Task\n\n```csharp\nusing System.Threading.Tasks;\n\n//通过Lambda表达式创建\nTask t = new Task(() =>\n{\n// to do\n});\nt.Start();\n\n// 传入函数\nvoid yourTaskFun(){\n    // to do\n}\nTask t2 = new Task(yourTaskFun);\nt.Start();\n```\n\n- 含返回值的Task\n\n```csharp\n// 用Task<TResult>\nTask<int> t = new Task<int>(() => {\n    return 114; // 返回int类型\n});\nt.Start();\n// 可以用t.Result获得返回值\n```\n\n#### 前台线程与后台线程\n\n- 前台线程\n  - 所有前台线程都结束，应用程序才可以结束；默认创建的线程都是前台线程\n- 后台线程\n  - 只要所有前台线程结束，后台线程自动结束\n  - 通过Thread.IsBackground设置后台线程\n  - 必须在Start之前设置后台线程\n\n### 线程同步\n\n#### 互斥量\n\n- mutex\n\n```csharp\nMutex mut_operate = new Mutex(); // mutex信号量\n\n// 使用\nmut_operate.WaitOne();// 申请\n// 互斥访问...\nmut_operate.ReleaseMutex();// 释放\n```\n\n- Semaphore\n\n```csharp\nSemaphore semaphore = new Semaphore(usable_num , max_num + 1); // (初始值, 最大并发)\n\n// 使用类似\nsemaphore.WaitOne();// 申请\n// 互斥访问...\nsemaphore.Release();// 释放\n// semaphore.Release(2); // 可以指定释放次数\n```\n\n#### ManualResetEvent与AutoResetEvent\n\n- ManualResetEvent\n\n```csharp\nstop_signal = new ManualResetEvent(false); // 初始为false\n\n// 等待1毫秒，如果在等待时间内信号触发则立即退出等待\n// 这里相当于一直在while(!false)，直到stop_signal为true\nwhile (!stop_signal.WaitOne(1)){\n    // to do\n}\n```\n\n```csharp\n// 设置stop_signal为允许线程运行，这会使得waitone为true\nstop_signal.Set();\n\n// 由于是手动信号，所以如果需要重置要手动重置\nstop_signal.Reset();\n```\n\n- AutoResetEvent\n\n与ManualResetEvent效果相同，只不过WaitOne()有效并被读取一次后会立即自动置为False，不需要手动Reset，这意味着它一次只能通知一个线程\n\n## 线程缺点\n\n- 线程上下文信息消耗计算机资源\n\n- 线程上下文切换过程，线程会带来资源特殊要求和潜在冲突。如果线程过多，系统管理线程的负担会加大，则其中大多数线程都不会产生明显的进度\n\n- 线程控制代码非常复杂，并可能产生许多bug\n\n- 线程的非正常终结会造成资源浪费影响系统的运行性能\n\n## 信号量实例——生产者消费者协同\n\n- 生产一个\n\n```csharp\nprivate void produce_one()\n{\n    string msg;\n    while (!stop_signal.WaitOne(1))\n    {\n\n        mut_operate.WaitOne();\n        if (usable_num == max_num)\n        {\n            mut_operate.ReleaseMutex(); // 资源已满，释放互斥区\n            continue; // 重新排队\n        }\n        mut_operate.ReleaseMutex();\n        msg = Thread.CurrentThread.Name + \"即将开始工作！\\n\\t当前资源总量为：\" + usable_num + \"，资源上限为：\" + max_num + \"\\n\\t正在工作...\";\n        callback(msg, listname); // callback是上文提到的线程跨域访问的回调，用于在窗体上显示信息，下文的callback同理\n        Random rand = new Random();\n        Thread.Sleep(rand.Next(0, Produce_time_upper_bound)); // 模拟工作时间\n\n        while (true)\n        {\n            mut_operate.WaitOne();\n            if (usable_num == max_num)\n            {\n                mut_operate.ReleaseMutex();// 满了则释放，重新申请\n                continue;\n            }\n            else\n            {\n                break;\n            }\n        }\n        usable_num++; // 不满则放入货架\n\n        msg = Thread.CurrentThread.Name + \"生产完成，当前资源总量为：\" + usable_num + \"\\n\";\n        callback(msg, listname);\n        callback_2.Invoke(usable_num);\n        semaphore.Release(); // 信号量新增一个货物\n        mut_operate.ReleaseMutex(); // 允许修改访问货架\n\n    }\n    msg = Thread.CurrentThread.Name + \"结束\";\n    callback(msg, listname);\n}\n```\n\n- 消费一个\n\n```csharp\nprivate void consume_one()\n{\n    string msg;\n    while (!stop_signal.WaitOne(1))\n    {\n        semaphore.WaitOne(); // 向货架申请一个资源\n\n        msg = Thread.CurrentThread.Name + \"即将开始工作！\\n\\t当前资源总量为：\" + usable_num + \"，资源上限为：\" + max_num + \"\\n\\t正在工作...\";\n        callback(msg, listname);\n        Random rand = new Random();\n        Thread.Sleep(rand.Next(0, Consume_time_upper_bound));// 模拟消费\n        mut_operate.WaitOne();// 修改货架数据\n        usable_num--;\n        mut_operate.ReleaseMutex();// 释放货架\n        msg = Thread.CurrentThread.Name + \"消费完成，当前资源总量为：\" + usable_num + \"\\n\";\n        callback(msg, listname);\n        callback_2.Invoke(usable_num);\n    }\n    msg = Thread.CurrentThread.Name + \"结束\";\n    callback(msg, listname);\n}\n```\n\n- 初始化\n\n```csharp\npublic void start_simulation()\n{\n    stop_signal = new ManualResetEvent(false);\n\n    int i = 0;\n    while (i < producer_num)\n    {\n        Thread thread = new Thread(new ThreadStart(produce_one));\n        thread.Name = \"生产者\" + i + \"号\";\n        thread.IsBackground = true;\n        thread.Start();\n        i++;\n    }\n    i = 0;\n    while (i < consumer_num)\n    {\n        Thread thread = new Thread(new ThreadStart(consume_one));\n        thread.Name = \"消费者\" + i + \"号\";\n        thread.IsBackground = true;\n        thread.Start();\n        i++;\n    }\n}\n```\n\n- 信号量初始化\n\n```csharp\nsemaphore = new Semaphore(usable_num , max_num); \n// usable_num : 初始的资源数量\n// max_num : 最大可以存放的资源数量\n\n// 这里的max_num并不能起到限制所用\n// 如果semaphore超过max_num会直接抛出异常\n// 所以可以稍微设大一些，比如max_num+1\n```\n\n","tags":["编程","技术"],"categories":["Windows原理与应用"]},{"title":"Windows原理与应用（二）——程序进程与进程间通信","url":"/合集/Windows原理与应用/Windows原理与应用（二）——程序进程与进程间通信/","content":"# Windows原理与应用（二）——程序进程与进程间通信\n\n{% note info %} \n\n## 系列\n\n[Windows原理与应用（一）—— 简介 | 德依安-BLOG (ddg-302.github.io)](https://ddg-302.github.io/合集/Windows原理与应用/Windows原理与应用（一）/)\n<p style=\"color:grey\">[本文]Windows原理与应用（二）——程序进程与进程间通信 | 德依安-BLOG (ddg-302.github.io)</p>\n\n[Windows原理与应用（三）——线程间通信与同步 | 德依安-BLOG (ddg-302.github.io)](https://ddg-302.github.io/合集/Windows原理与应用/Windows原理与应用（三）——线程间通信与同步/)\n\n{% endnote %}\n\n## 程序、进程与线程\n\n- 进程与程序不同，它是程序执行时的标志，程序是存放在磁盘中的可执行文件，而进程是程序执行的一个过程，**程序是静态的，进程是动态的**\n\n  一个程序可执行多次产生多个进程实例，进程随运行动态变化，进程共享计算机资源、互相通信，由OS管理\n\n- 线程是最小的执行单位，它几乎不拥有系统资源，它是系统调度的基本单位\n\n  在单CPU单核技术中，OS不断切换线程运行，这个过程成为**并发**；多核或多CPU中的程序可以**并行**\n\n  一个进程可以拥有多个线程，一个线程只属于一个进程\n\n### 操作系统中的进程\n\n- 操作系统中的进程与用户进程并发运行，用户进程由操作系统创建和调用\n- 用户进程也可以创建和调用别的进程\n- 被创建的进程与创建者构成父子关系\n\n### 进程与线程的关系图\n\n![进程与线程的关系图](进程与线程的关系图.png)\n\n## 进程对象结构\n\n![进程对象结构](进程对象结构.png)\n\n- Windows将硬件资源虚拟后分配给进程，还创建多种软件资源\n\n  软件资源分为两类，一类是只能由操作系统管理和使用的`内核资源`，如权限令牌，底层时间，互斥量等；另一类是用户程序使用的资源，如普通内存空间，文件资源等\n\n- `内核资源`：每个内核对象是由系统内和创建的一块内存区，这块内存区的数据结构成员对应对象的属性，在初次创建内核对象时，创建函数获得标识这个内核的`句柄`（`HANDLE`），句柄只能由特定的API调用，不可以直接操作\n\n- `句柄`：句柄是一个4B（64位机中为8B）长的数值，用于标识应用程序中的不同实例，要注意**句柄不是指针**，它只是表示一个对象，这个对象的物理地址由操作系统安排，物理地址并不是固定的，但句柄值是固定的，需要使用指定的API才可以操作句柄指向的对象\n\n  句柄是进程相关的，同一个句柄值在不同进程中意义不同\n\n  关闭使用完毕的资源句柄后，系统不会马上销毁它，内核对象生命期可以比创建它的进程长\n\n### 进程创建过程\n\n1. 打开文件映像\n2. 创建Windows进程对象\n3. 创建初始线程对象，为其分配内存堆栈、运行上下文\n4. 通知内核系统为进程运行作准备\n5. 执行初始线程\n6. 导入需要的DLL，初始化地址空间，由程序入口地址开始执行进程\n\n## 进程的创建与启动 - C#\n\n- 创建wpf工程\n\n- 实例化一个Process类并打开应用程序，Process类在System.Diagnostics命名空间下\n\n```csharp\nusing System.Diagnostics;\n\nProcess mycmd = new Process();\nmycmd.StartInfo.FileName = \"cmd.exe\";// 设置启动程序\nmycmd.StartInfo.CreateNoWindow = true;// 不开启窗口\nmycmd.StartInfo.UseShellExecute = false; // 不使用shell\nmycmd.StartInfo.RedirectStandardOutput = true; // 重定向输入输出\nmycmd.StartInfo.RedirectStandardInput = true;\n\nmycmd.Start(); // 启动进程 \n\t\t\t // 这个函数有返回值，true为启动成功，false为启动失败\n```\n\n- 关闭应用程序\n\n```csharp\n// 法1\nmycmd.Kill(); // 直接杀死进程\n```\n\n```csharp\n// 法2\n// 得到程序中所有正在运行的进程\nProcess[] preo = Process.GetProcesses(); \nforeach(var item in preo){\n    item.Kill(); // 杀死进程\n}\n```\n\n## 进程间通信\n\n- 高级通信（<u>IPC</u>[^1]）\n  - 传输数据量大，超过几十个字节\n- 低级通信（同步控制）\n  - 传输数据量小，少于数个字节，或仅是位单位\n\n### 进程间通信方法分类\n\n1. 共享内存（剪贴板、COM、DLL、DDE、文件映射）\n2. 消息WM_COPYDATA\n3. 邮槽\n4. 管道（有名管道，无名管道）\n5. Windows套接字\n6. NetBIOS特殊的网络应用\n\n### IPC选择考虑\n\n1. 通信主题是进程内的线程还是不同进程之间\n2. 进程是需要网络还是本地机制\n3. 通信的进程运行的OS是否有差异\n4. 有些进程通信机制是只用于图形化窗体界面的，而不适用于控制台程序\n5. 通信目的是用于同步控制还是大量数据的交换\n\n### 管道通信\n\n由操作系统创建管道对象，发送进程向管道中写数据，接收进程从管道中读数据\n\n- 无名管道\n  - 只能在单一进程内使用\n\n- 有名管道\n  - 以「文件名」来表示，可以用于不同进程间通信\n\n### 管道通信实现\n\n1. 建立连接：服务端创建命名管道NamedPipeServerStream类实例，调用WaitForConnection方法等待连接，这个函数将阻塞线程\n2. 通信实现：建立连接后，客户端和服务端可以通过Stream流的Read方法和Write方法进行读写通信\n3. 连接终止：任何一方使用Close方法可以关闭管道连接\n\n服务端：\n\n```csharp\nNamedPipeServerStream pipeserver; // 实例化\n\npublic void start_listen()\n{\n    // 由于WaitForConnection()会阻塞线程，而这服务端客户端都写在一个进程内，所以要开启一个进程避免进程卡死\n    Task task = new Task(() =>\n    {\n        while (true)\n        {\n            pipeserver = new NamedPipeServerStream(\"my_pipe\", PipeDirection.InOut, 2, PipeTransmissionMode.Byte, PipeOptions.Asynchronous);// (管道名， 确定管道方向枚举值， 共享同一服务器实例的最大数量， 确定管道传输模式)\n            pipeserver.WaitForConnection();\n            receive_msg(); // 收到消息，调用处理\n        }\n\n    });\n    task.Start();\n}\n\npublic void receive_msg()\n{\n    // 新建Stream流准备读写\n    StreamReader sreader = new StreamReader(pipeserver);\n    StreamWriter swriter = new StreamWriter(pipeserver);\n    swriter.AutoFlush = true;\n\n    string msg = sreader.ReadLine(); // 读管道内的消息\n    if (msg == null)\n        return;\n    Console.WriteLine(msg);\n    swriter.WriteLine(\"信息接收完毕\"); // 回复消息给发送方\n    swriter.Close(); // 关闭管道连接\n}\n```\n\n客户端：\n\n```csharp\nNamedPipeClientStream pclient = new NamedPipeClientStream(\".\", \"my_pipe\", PipeDirection.InOut); // 客户端连接名为「my_pipe」的管道\n\nTask task = new Task(() =>\n{\n    try\n    {\n        if (!pclient.IsConnected)\n            pclient.Connect(10000); // 设置超时等待\n    }\n    catch\n    {\n        MessageBox.Show(\"连接超时！\", \"警告\", MessageBoxButton.OK, MessageBoxImage.Warning);\n        return;\n    }\n    // 准备stream\n    StreamWriter swriter = new StreamWriter(pclient); \n    swriter.AutoFlush = true;\n    StreamReader sreader = new StreamReader(pclient);\n    \n    swriter.WriteLine(msg); // 发送消息\n    string return_msg = sreader.ReadLine(); // 接收管道发回的消息\n    Console.WriteLine(return_msg);\n});\ntask.Start();\n```\n\n### 重定向方式\n\n- 控制台进程文件描述符\n\n  - 标准输入\n  - 标准输出\n  - 标准错误输出\n- 普通进程\n\n  - 从键盘接收输入→输出到屏幕\n- 重定向\n\n  - 从文件输入→屏幕输出\n  - ......\n- 例子\n\n  - 使用控制台重定向符`>`和`<`\n\n```\n  dir > file.txt // 将dir指令的输出存放到file.txt中\n  cmd >> file.txt // 将接下来的所有屏幕输出都存放到file.txt，输入exit退出\n  cmd < file.txt // 将file.txt中的指令输出到cmd\n```\n\n使用控制台重定向获取控制台输出实例\n\n```csharp\nusing System.Diagnostics;\n\nProcess mycmd = new Process();\nmycmd.StartInfo.FileName = \"cmd.exe\";// 设置启动程序\nmycmd.StartInfo.CreateNoWindow = true;// 不开启窗口\nmycmd.StartInfo.UseShellExecute = false; // 不使用shell\nmycmd.StartInfo.RedirectStandardOutput = true; // 重定向输入输出\nmycmd.StartInfo.RedirectStandardInput = true;\n\nmycmd.Start(); // 启动进程 \n\t\t\t // 这个函数有返回值，true为启动成功，false为启动失败\n\npublic void excute_command(string command)\n{\n\t// StandardInput重定向输入\n    mycmd.StandardInput.WriteLine(command);\n    Console.WriteLine(\"输入\");\n\n    while (true)\n    {\n        // 按行读取\n        // StandardOutput重定向输出\n        Console.WriteLine(mycmd.StandardOutput.ReadLine());\n        if (mycmd.StandardOutput.EndOfStream)\n            break; // 读完退出\n    }\n}\n```\n\n## 练习\n\n1. 通过重定向机制实现进程间通信\n   - 调用getmac获取网卡mac\n   - 调用shutdown命令关闭或重启电脑\n2. 通过管道机制实现进程间通信\n   - 客户端向服务端发送数据\n   - 服务端显示数据\n\n程序将会以WPF窗体程序的形式呈现，为了让输出显示在窗体上，将不使用Console.WriteLine()方法，而是会有一些特殊的处理，这也将在之后整理放出\n\n[^1]: IPC：interproces communications，是通信进程处于同一台机器中的通信机制，IPC经常使用C/S模式\n\n","tags":["编程","技术"],"categories":["Windows原理与应用"]},{"title":"Windows原理与应用（一）——简介","url":"/合集/Windows原理与应用/Windows原理与应用（一）/","content":"# Windows原理与应用（一）——简介\n\n## 前言\n\n本系列是关于`Windows原理与应用`课程的部分相关笔记，可能并不是很详细，仅仅是个人记录\n\n{% note info %} \n\n## 系列\n\n<p style=\"color:grey\">Windows原理与应用（一）—— 简介 | 德依安-BLOG (ddg-302.github.io)</p>\n\n[Windows原理与应用（二）——程序进程与进程间通信 | 德依安-BLOG (ddg-302.github.io)](https://ddg-302.github.io/合集/Windows原理与应用/Windows原理与应用（二）——程序进程与进程间通信/)\n\n[Windows原理与应用（三）——线程间通信与同步 | 德依安-BLOG (ddg-302.github.io)](https://ddg-302.github.io/合集/Windows原理与应用/Windows原理与应用（三）——线程间通信与同步/)\n\n{% endnote %}\n\n## 简介\n\n- 在具有一般编程基础（c++和c#）条件下，将引用需求与系统API进行对接\n- 理解操作系统原理中的并发，同步等概念\n- 了解并使用Windows平台中的特性，如dll/com等\n\n## 主要内容\n\n1. 进程间通信\n2. 线程通信与同步\n3. 文件系统管理\n4. 注册表\n5. 动态链接库的创建与使用\n6. Windows COM原理与技术\n7. Windows窗体原理与消息处理机制\n\n## 前置知识\n\n- C++/C#编程语言的使用\n- 数据结构\n\n## Windows的特点\n\n- 面向对象\n\n  - Windows中，窗口、菜单、事件都是对象，对界面元素的操作和消息/事件的处理都涉及到对象。这些对象的属性和操作，由API的数据结构和函数提供\n- 消息/事件驱动\n\n  - Windows通过维护消息队列的方式处理用户操作系统事件，用户的操作会向消息队列中插入一条新的消息，其他应用程序收到消息后会调用相应的消息处理函数进行处理\n- 资源共享与数据交换\n  - 标准的MS-DOS程序运行时，可独占计算机所有资源。但Windows是一种<u>抢先式</u>[^1]多任务操作系统，所以Windows应用程序必须和正在运行的其他程序共享这些资源\n- 与设备无关的GDI\n  - Windows为应用程序提供了丰富的与设备无关API，免去了为不同的I/O设备编写软件的不同版本之烦恼。如利用与设备无关的GDI，应用程序使用同一函数，可在不同的显卡、打印机和显示器上输出同一个图形。\n\n## Windows编程工具——.NET框架\n\n- .NET框架是微软公司为了与Sun/Oracle公司的Java（EE）竞争，于2000年6月提出来的一种新的跨语言、跨平台、面向组件的操作系统环境，适用于Web服务（Web services）和因特网（Internet）分布式应用程序的生成、部署和运行\n- .NET框架也是Windows Vista、Windows 7和Windows 8等新版Windows操作系统的核心部件\n- .NET框架基于CLR运行，CLR类似于JVM，也是一个虚拟机，具有自动垃圾回收，运行时安全性保护，异常处理等高级功能\n\n## Windows编程工具的选择——关于Visual Studio\n\n- 在Visual Studio提供的各种语言工具中，只有Visual C++才能编写传统的Windows应用程序，VC也是VS中u唯一的一种可以同时[混合]编写非托管（API与MFC/ATL）程序和托管（.NET）程序的工具\n- VS中的其他语言工具（如C#、VB和F# 等）则只能编写.NET环境下的<u>托管程序</u>[^2]\n\n[^1]: 运行抢先式多任务处理模式,各进程占用CPU的时间由系统调度程序决定,当调度程序检测出有比当前任务优先级更高的程序事件后,暂停当前任务并将CPU时间分配给优先级更高的进程——摘自百度百科。简单来说就是Windows操作系统不允许一个程序长时间占有CPU，而是会根据优先级进行调度。\n[^2]: 这是.NET的特性，.NET基于CLR运行托管代码，程序交由CLR进行管理，确保其安全性。但是CLR也允许越过托管与非托管的边界，调用其他的非托管库，这个特性成为互操作性。[什么是“托管代码”？| Microsoft Docs](https://docs.microsoft.com/zh-cn/dotnet/standard/managed-code)","tags":["编程","技术"],"categories":["Windows原理与应用"]},{"title":"2021.7动画推荐","url":"/合集/动画推荐/2021_7 动画推荐/","content":"\n# 2021.7 动画推荐\n\n{% note warning %} \n\n**主观判断警告**!\n\n本文纯粹出于笔者个人主观经验与感受而成，如有任何不同意见欢迎友善交流讨论\n\n没有提到的作品笔者没看，或不符合笔者个人兴趣，或观看价值较低\n\n另外，本文不提供动画简介，对感兴趣的动画可以点击「更多信息」访问[Bangumi 番组计划](https://bangumi.tv/)网站的详情页面\n\n{% endnote %}\n\n## 小林さんちのメイドラゴンS（小林家的龙女仆s）\n\n![小林さんちのメイドラゴンS](小林さんちのメイドラゴンS.jpg)\n\n推荐度：90分\n\n京都出品，必属精品。同第一季一样，依然是温馨轻松的日常动画，画风清新精致，剧情轻松活泼，适合日常萌系爱好者。\n\n更多信息：[小林さんちのメイドラゴンS | Bangumi 番组计划](https://bangumi.tv/subject/274234)\n\n关键词：`日常`，`玄幻`，`治愈`，`美少女`，`京都动画`，`轻百合`\n\n## 人偶学园\n\n![人偶学园](人偶学园.jpg)\n\n推荐度：90分\n\n米哈游制作的崩坏三衍生动画，泡面番，剧情极其沙雕有趣，如果不了解崩坏三趣味会下降很多，有时可能连笑点都无法理解，优质的粉丝向作品。\n\n更多信息：[人偶学园 | Bangumi 番组计划](https://bangumi.tv/subject/340275)\n\n关键词：`搞笑`，`崩坏3rd`，`泡面`，`国产`\n\n## Sonny Boy -サニーボーイ-（漂流少年）\n\n![Sonny Boy](SonnyBoy.jpg)\n\n推荐度：85分\n\n一场奇幻的漂流历险记，学生们获得了各种不同的超能力，各自的日常生活也全都被打乱。故事中的不同人物在漂流中都表达了不同的人生哲学，是一部值得思考回味的动画作品，推荐。\n\n更多信息：[Sonny Boy -サニーボーイ- | Bangumi 番组计划](https://bangumi.tv/subject/332649)\n\n关键词：`奇幻`，`成长`，`哲学`\n\n## 海賊王女（海贼王女）\n\n![海賊王女](海賊王女.jpg)\n\n可推荐度：80分\n\n本来应该是10月的动画，但是北美地区先行开播了，所以当时在crunchyroll网站上可以看到最新的带英文字幕的海贼王女。本作有优良的作画和音乐，打斗动作流畅，人设也很不错，轻微乙女向。然而后续的剧情发展有点不是那么有趣。\n\n更多信息：[海賊王女 | Bangumi 番组计划](https://bangumi.tv/subject/311310)\n\n关键词：`原创`，`战斗`，`冒险`\n\n\n## 乙女ゲームの破滅フラグしかない悪役令嬢に転生してしまった…Ｘ（转生成为了只有乙女游戏破灭Flag的邪恶大小姐 第二季）\n\n![乙女ゲームの破滅フラグしかない悪役令嬢に転生してしまった…Ｘ](乙女ゲームの破滅フラグしかない悪役令嬢に転生してしまった…Ｘ.jpg)\n\n推荐度：75分\n\n单纯的沙雕动画，所谓的暗魔法，皇室贵族内斗全是像过家家一样，声优阵容极其豪华，真扎，小水，松冈，美宝林...\n问题是女主过于迟钝，甚至是过于傻了，第一季看完第二季依然是这样，有点审美疲劳了。\n\n更多信息：[乙女ゲームの破滅フラグしかない悪役令嬢に転生してしまった…Ｘ | Bangumi 番组计划](https://bangumi.tv/subject/309056)\n\n关键词：`搞笑`，`乙女`，`逆后宫`\n\n## 白い砂のアクアトープ（白沙水族馆）\n\n![白い砂のアクアトープ](白い砂のアクアトープ.jpg)\n\n推荐度：75\n\n慢节奏日常动画，讲述退役偶像和一个海洋生物爱好者少女在水族馆工作的故事，剧情几乎毫无波澜，就是平平淡淡的打工日常。\n\n更多信息：[白い砂のアクアトープ | Bangumi 番组计划](https://bangumi.tv/subject/325281)\n\n关键词：`日常`，`轻百合`，`打工`\n\n## 100万の命の上に俺は立っている 第2シーズン（我立于百万生命之上 第二季）\n\n![100万の命の上に俺は立っている 第2シーズン](100万の命の上に俺は立っている第2シーズン.jpg)\n\n推荐度：75\n\n制作过于贫穷，但是剧情相对还不错，主角没有特别脱离一般常识的操作，男主非龙傲天，比较有担当，其他几个队友也并非都是花瓶，其中的花瓶队友也在缓慢地成长。本作比同期的「侦探已死」，「精灵幻想记」之类的画面精良但是剧情烂的动画要好上太多了，可以看一看。\n\n更多信息：[100万の命の上に俺は立っている 第2シーズン | Bangumi 番组计划](https://bangumi.tv/subject/322859)\n\n关键词：`异世界`，`战斗`\n\n## ジャヒー様はくじけない（迦希女王不会放弃）\n\n![ジャヒー様はくじけない](ジャヒー様はくじけない.jpg)\n\n推荐度：75分\n\n迦希女王失去力量变成幼女体型，但是又能暂时通过魔石恢复成年身材（像奥特曼一样），两个愿望同时满足。虽然迦希女王一直喊着要复兴魔界，但事实上主线还是讲迦希女王过着贫穷的生活，天天去居酒屋打工，每天都要各种吃瘪的故事。登场人物全部都是女性，不知道的还以为是芳文社的动画（并不是），典型的废萌作，基本没有主线，人物画得很可爱，喜欢废萌的可以一看。\n\n更多信息：[ジャヒー様はくじけない！ | Bangumi 番组计划](https://bangumi.tv/subject/333349)\n\n关键词：`废萌`，`日常`\n\n## 出会って5秒でバトル（见面5秒开始战斗）\n\n![出会って5秒でバトル](出会って5秒でバトル.jpg)\n\n推荐度：65分\n\n制作太过于贫穷，就剧情而言，前半段的智斗还是挺有意思的，但是后半段女主加入之后智斗的成分就显得无趣了很多，再加上作画的各种崩坏，相当劝退。原本男主的能力还是很有意思的，在前半部分的几集中也确实让人感受到「智」的成分，可惜越往后剧情质量越差，最后烂尾了。\n\n更多信息：[出会って5秒でバトル | Bangumi 番组计划](https://bangumi.tv/subject/319286)\n\n关键词：`战斗`，`大逃杀`，`智斗`\n","tags":["二次元","动画"],"categories":["动画推荐"]},{"title":"基于MyQQ机器人框架搭建qq机器人","url":"/合集/qq机器人/基于MyQQ机器人框架搭建qq机器人/","content":"\n# 基于MyQQ机器人框架搭建qq机器人\n\n## 前言\n\n很早以前就有搭建一个能自动收发消息的qq机器人的想法，但是一直找不到可行的方法\n\nwebqq被腾讯关闭了，无法使用；qq网络消息是加密的，而且本人的计网水品也达不到抓包并解密的程度；qq的本地消息数据库也是qq自建的，无法从外部读取；用windows的api直接获取窗体数据太过于繁琐而且灵活性很差\n\n在种种方式都不可行的情况下，只能借助第三方工具，MyQQ机器人框架，是一款功能强大的qq消息收发机器人框架，可以接收文字、图片、点赞、好友登录离线等多种qq消息，也可以发送文字、图片、回复等多种qq消息\n\n在这里我们借用MyQQ机器人框架帮助我们解决qq消息的IO问题\n\n**MyQQ YYDS！**\n\n## 准备\n\n### MyQQ机器人框架\n\n进入MyQQ机器人官网首页（[MyQQ机器人官网首页](https://www.myqqx.com/)），按照教程（[框架使用教程-新手必看](https://bbs.myqqx.com/forum.php?mod=viewthread&tid=82)）下载并配置好MyQQ备用\n\n[相关文档首页 | MyQQ机器人 ](https://www.myqqx.com/0.doc.html)\n\n### python\n\n安装好MyQQ机器人后不需要安装其他的插件，我们将直接使用MyQQ官方提供的`HTTP API`插件\n\n使用这个插件我们需要自己构建一个web服务器来接收MyQQ获取到的消息，为了方便和后续的扩展开发，我们选择`python`语言进行开发\n\n安装python并配置好相关环境\n\n#### 将使用到的python相关的包\n\n`fastapi`、`uvicorn`、`pydantic`\n\n```bash\npip install fastapi\npip install uvicorn\npip install pydantic\n```\n\n这三个包用于搭建web服务器，在本项目中不需要实现很复杂的web服务，这个服务器也将一直在本地运行，因此可以看我的另一篇博客快速入门使用：[python实现web api](https://ddg-302.github.io/python%E5%AE%9E%E7%8E%B0webapi/)\n\n## MyQQ机器人框架消息收发\n\n如果已经根据教程设置好MyQQ了，那么应该能够知道，MyQQ的接收到消息后会主动发送post请求到指定的url；我们希望发送消息时，则可以post或get到MyQQ指定的url\n\n如果不知道post和get请求是什么，请百度搜索`REST API`\n\n## 服务器基础结构\n\n首先，构建一个基础的工程目录\n\n```\n│  main.py\n│\n└─module\n```\n\n![目录结构](image-20211121172803706.png)\n\n`module`文件夹一会就会使用到，首先在`main.py`文件中写下：\n\n```python\nfrom fastapi import FastAPI, Body\nfrom fastapi.middleware.cors import CORSMiddleware\nimport uvicorn\n\napp = FastAPI()\n# 解决跨域\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"]\n)\n\n@app.post('/')\ndef fun1('''在这里填入参数'''):\n    # 业务处理\n    return {\"status\":1} # MyQQ要求返回1表示允许其他插件继续处理\n\nif __name__ == \"__main__\":   \n    uvicorn.run(app = app, host = '''填入本地ip''', port = '''指定的端口号''')\n```\n\n这样一个能处理post请求的web服务器就搭建完成了，由于这个服务器只需要接收post请求，所以这里只需要写一个post即可\n\n{% note danger %} 注意：\n\n在解决跨域时，这里直接允许所有的访问，这在生产环境中显然是不安全的，但是仅仅在本地内网使用的情况下，先姑且这样处理\n\n {% endnote %}\n\n## 接收一个消息\n\n### 编写post\n\n根据MyQQ官网中关于[消息回调](https://www.myqqx.cn/6.HTTPAPI/5.%E6%B6%88%E6%81%AF%E5%9B%9E%E8%B0%83.html#%E6%B6%88%E6%81%AF%E5%9B%9E%E8%B0%83)的信息，MyQQ给出的post请求携带json格式信息，其内容如下：\n\n```json\n{\n    \"MQ_robot\": \"1330166568\",\n    \"MQ_type\": 1,\n    \"MQ_type_sub\": 0,\n    \"MQ_fromID\": \"1330166565\",\n    \"MQ_fromQQ\": \"1330166565\",\n    \"MQ_passiveQQ\": \"1330166568\",\n    \"MQ_msg\": \"123%E6%B5%8B%E8%AF%95,loveyou\",\n    \"MQ_msgSeq\": \"1482636593\",\n    \"MQ_msgID\": \"1243\",\n    \"MQ_msgData\": \"4F 48 BB 25 4F 48 BB 28 00 06 36 04 09 95 68 BD 1F 40 00 A6 00 00 00 2D 00 05 00 02 00 01 00 06 00 04 00 01 01 01 00 09 00 06 00 01 00 00 00 01 00 0A 00 04 01 00 00 00 00 01 00 04 00 00 00 00 00 03 00 01 02 3A 03 4F 48 BB 25 4F 48 BB 28 E7 B9 55 10 DA 5A 21 52 F4 EA 9C 41 C7 BE F7 A8 00 0B 04 DB 60 75 66 A5 02 43 00 00 00 00 01 00 00 00 01 4D 53 47 00 00 00 00 00 60 75 66 A5 58 5F 3D 31 00 00 00 00 0B 00 86 31 00 0C E5 BE AE E8 BD AF E9 9B 85 E9 BB 91 00 00 01 00 0C 01 00 09 31 32 33 E6 B5 8B E8 AF 95 19 00 1E 01 00 1B AA 02 18 08 08 9A 01 13 78 80 80 04 C8 01 00 F0 01 00 F8 01 00 90 02 00 CA 04 00 0E 00 07 01 00 04 00 00 00 00\",\n    \"MQ_timestamp\": \"1630051875\",\n}\n```\n\n详细的参数含义请见上面链接中的文档说明\n\n参数数量比较大，因此我们考虑使用模型类来处理信息，在[python实现web api](https://ddg-302.github.io/python%E5%AE%9E%E7%8E%B0webapi/)展示的模型类就是它，我们把这个模型类放到`module`文件夹下的`MSG_CALL_BACK.py`文件中\n\n![工程结构](image-20211121172833072.png)\n\n```python\nfrom pydantic import BaseModel\n\nclass MSG_CALL_BACK(BaseModel):   \n    MQ_robot: str\n    MQ_type: int\n    MQ_type_sub: int\n    MQ_fromID: str\n    MQ_fromQQ: str\n    MQ_passiveQQ: str\n    MQ_msg: str\n    MQ_msgSeq: str\n    MQ_msgID: str\n    MQ_msgData: str\n    MQ_timestamp: str\n```\n\npost处理\n\n首先引入模型类\n\n```python\nfrom module.MSG_CALL_BACK import MSG_CALL_BACK\n```\n\n\n\n```python\n@app.post('/')\ndef read_model(item:MSG_CALL_BACK = Body(...)):   \n    print(item)\n    return {\"status\":1}\n```\n\n我们把fun1的名字改成了read_model，参数命名为item，并指定是MSG_CALL_BACK类型以便于代码编写时的处理，在函数中打印出item，最后返回状态为1\n\n即使不指定item的类型在python中也是完全可行的，只不过指定类型后在编写时会有代码提示，也便于代码的理解\n\n### 指定本机地址和端口号\n\n```python\nif __name__ == \"__main__\":   \n    uvicorn.run(app = app, host = \"0.0.0.0\", port = \"8000\")\n```\n\n在MyQQ的HTTP API设置中也做好相同的设置\n\n![设置回调](image-20211121110052207.png)\n\n### 试验结果\n\n到这里我们已经可以做到接收一个消息了，来试验一下是否发送成功吧\n\n1. 首先登陆机器人qq\n   - ![登陆机器人qq](image-20211121110314782.png)\n\n2. 启动服务器\n\n   - 控制台中输入：\n\n    ```bash\n     uvicorn main:app --reload\n    ```\n\n   {% note warning %}\n\n   注意这里的`main`表示我的代码在`main.py`文件中，而且fastapi实例名为`app`，如果你的设置不是这样的，那么应当修改对应的参数\n\n   {% endnote %}  \n\n3. 然后向这个机器人qq发送一条消息\n\n   - ![发送消息](image-20211121110608827.png)\n   - ![接收回调](image-20211121110956505.png)\n\n我们确实成功接收到消息了，而且消息内容在MQ_msg中\n\n### 进一步处理消息\n\n有一个问题，如果消息内容是中文，那么消息在传送时会转码\n\n![发送消息](image-20211121111343405.png)\n\n![接收消息](image-20211121111451527.png)\n\n因此我们需要将消息内容进一步解码\n\n解码需要引入新的包\n\n```python\nfrom urllib.parse import unquote\n```\n\n使用unquote进行解码\n\n```python\n@app.post('/')\ndef read_model(item:MSG_CALL_BACK = Body(...)):   \n    received_msg = unquote(item.MQ_msg)\n    print(received_msg)\n    return {\"status\":1}\n```\n\n![回调接收](image-20211121112304982.png)\n\n这样就能获取到正常的消息啦\n\n### 实现消息接收的完整代码\n此时的目录结构：\n\n```\n│  main.py\n│\n└─module\n|      MSG_CALL_BACK.py\n```\n\n![目录结构](image-20211121160707142.png)\n\n`main.py`:\n\n```python\nfrom fastapi import FastAPI, Body\nfrom fastapi.middleware.cors import CORSMiddleware\nimport uvicorn\nfrom module.MSG_CALL_BACK import MSG_CALL_BACK # 引入模型类\nfrom urllib.parse import unquote\n\n\napp = FastAPI()\n# 解决跨域\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"]\n)\n\n@app.post('/')\ndef read_model(item:MSG_CALL_BACK = Body(...)):   \n    received_msg = unquote(item.MQ_msg)\n    print(received_msg)\n    return {\"status\":1}\n\nif __name__ == \"__main__\":   \n    uvicorn.run(app = app, host = \"0.0.0.0\", port = \"8000\")\n```\n\n`MSG_CALL_BACK.py`:\n\n```python\nfrom pydantic import BaseModel\n\n\nclass MSG_CALL_BACK(BaseModel):   \n    MQ_robot: str\n    MQ_type: int\n    MQ_type_sub: int\n    MQ_fromID: str\n    MQ_fromQQ: str\n    MQ_passiveQQ: str\n    MQ_msg: str\n    MQ_msgSeq: str\n    MQ_msgID: str\n    MQ_msgData: str\n    MQ_timestamp: str\n```\n\n\n\n## 发送一个消息\n\n发送消息可以使用post也可以使用get，**笔者使用get请求**\n\n### post方式\n\n官网文档中的说法是：\n\n> 以下用`http://localhost:10002/MyQQHTTPAPI`作为演示\n>\n> 我们强烈推荐使用**POST**请求方式\n\n> 提交地址：\n>\n> ```\n> http://localhost:10002/MyQQHTTPAPI\n> ```\n>\n> 提交数据：\n>\n> ```json\n> {\n>     \"function\": \"Api_SendMsg\",  //要调用的函数英文名(查看右侧API列表)\n>     \"token\": \"666\",            //后台设置的token\n>     \"params\": {\n>         \"c1\": \"363751070\",            //参数1，要使用的机器人QQ\n>         \"c2\": \"2\",                    //参数2，消息类型，2为群，以此类推...\n>         \"c3\": \"320562077\",            //参数3，要发送的群号，以此类推...\n>         \"c4\": \"\",                     //参数4，要发送的QQ，此处发的是群，所以这个要留空，以此类推...\n>         \"c5\": \"你好，测试一下\"        //参数5，要发送的消息内容，以此类推...\n>     }\n> }\n> ```\n\n使用post的好处是比get更加安全，因为get是明文传输的，然而我试了好久都只能让post的消息以`Form`的形式提交，而MyQQ貌似并不能接收这样的post请求，所以**笔者将使用get请求**，如果你知道如何使用post实现发送消息，敬请留言交流\n\n### get方式\n\n使用get请求传参：\n\n> | 名称        | 参数                               |                 值                  |\n> | :---------- | :--------------------------------- | :---------------------------------: |\n> | 请求地址    | `http://localhost:10002/MyQQHTTPAPI` | `http://localhost:10002/MyQQHTTPAPI`  |\n> | 调用函数    | function                           | 要调用的函数英文名(查看右侧API列表) |\n> | token       | token                              |           后台设置的token           |\n> | 参数一      | c1                                 |   如有中文可能有需要URL UTF8编码    |\n> | 参数二      | c2                                 |   如有中文可能有需要URL UTF8编码    |\n> | 参数三      | c3                                 |   如有中文可能有需要URL UTF8编码    |\n> | 参数四      | c4                                 |   如有中文可能有需要URL UTF8编码    |\n> | 以此类推... | 以此类推...                        |   如有中文可能有需要URL UTF8编码    |\n>\n> \n\n从参数结构可以看出，调用函数和token是固定的必填项剩下的参数根据api列表直接c1，c2这样命名下去就好了，那么我们来写一个发送消息的函数\n\n- 新建类\n\n   为了后续的扩展开发，我们不妨新建一个文件来专门处理消息的发送\n\n   ```\n   │  main.py\n   │\n   └─business\n   │      msg_sender.py\n   │      router.py\n   └─module\n   |      MSG_CALL_BACK.py\n   ```\n   \n   ![目录结构](image-20211121160739347.png)\n   \n   我们构建这样一个目录结构，刚才写好的代码都在`main.py`中，模型类在MSG_CALL_BACK.py中\n   \n   现在新建一个`business`文件夹，在其中新建`msg_sender.py`和`router.py`\n   \n   `Router.py`将用于消息的进一步转发处理，因为上文提到，MyQQ机器人框架接收到的消息远不止聊天消息，好友上下线、邀请入群、群聊解散等等消息它都能接收，哪怕是聊天消息，也分好友聊天、群聊、临时会话，**不同的消息可能需要不同的处理方式**，这就是Router负责的内容，它负责分辨不同种类的消息，并将消息发送给对应模块处理\n   \n   `msg_sender.py`便是我们的消息发送模块了，它负责将消息通过get请求发送给MyQQ，MyQQ再将消息发送到qq     \n\n#### msg_sender\n\n##### 基本结构\n\n ```python\n class MsgSender:\n     def __init__(self) -> None:\n         pass\n     \n     @staticmethod\n     def send_pure_text_msg_2_person(self, target_qq:str, msg:str, robot_qq:str):\n         pass\n ```\n\n##### 查阅发送消息的api\n\n[API列表](https://www.myqqx.cn/5.%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91/1.%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/2.API%E5%88%97%E8%A1%A8.html#api%E5%88%97%E8%A1%A8)\n\n> | Api_SendMsg | 无返回值 | 向对象、目标发送消息 支持好友 群 讨论组 群临时会话 讨论组临时会话 |\n> | ----------- | -------- | ------------------------------------------- --------------- |\n> | 响应QQ | 文本型 | 机器人QQ |\n> | 消息类型 |          | 1好友 2群 3讨论组 4群临时会话 5讨论组临时会话 6在线临时会话 |\n> | 收信群_讨论组 | 文本型 | 发送群信息、讨论组信息、群临时会话信息、讨论组临时会话信息时填写 |\n> | 收信对象 | 文本型 | 最终接收这条信息的对象QQ |\n> | 内容 | 文本型 | 信息内容 |\n\n##### 根据api信息构建发送参数\n\n不妨使用如下图的配置信息\n\n![配置信息](image-20211121164714948.png)\n\n```python\nclass MsgSender:\n    def __init__(self) -> None:\n        self.httpapi_token = \"114514\"\n        self.httpapi_url = \"http://localhost:10087/MyQQHTTPAPI\"\n    \n    def send_pure_text_msg_2_person(self, target_qq:str, msg:str, robot_qq:str):\n        Values = {\n            \"function\" : \"Api_SendMsg\",\n            \"token\" : self.httpapi_token,\n            \"c1\" : robot_qq,\n            \"c2\" : \"1\",\n            \"c3\" : \"\",\n            \"c4\" : target_qq,\n            \"c5\" : msg\n        }\n```\n\n##### 转码消息\n\n接收消息的时候可以看到非英文字符都经过了一次转码再发送，因此我们在发送消息的时候也需要对中文字符进行转码\n\n引入包：\n\n```python\nimport urllib.parse\n```\n\n转码：\n\n```python\ndata = urllib.parse.urlencode(Values).encode(\"utf-8\") # MyQQ要求UTF编码\n```\n\n##### 消息发送\n\n引入包：\n\n```python\nimport requests\n```\n\n发送消息：\n\n```python\nrq = requests\nrq = requests.get(self.httpapi_url, params=Values)\n```\n\n##### 打印返回值\n\n返回值表示对方服务器的响应，打印返回值可以了解自己的请求是否被对方接收，对方是否正常响应、处理了我们的请求\n\n```python\nprint(rq.content.decode(\"utf-8\"))\n```\n\n##### msg_sender完整代码\n\n```python\nimport urllib.parse\nimport urllib.request\nimport requests\n\n\nclass MsgSender:\n    def __init__(self) -> None:\n        # 分别是MyQQ中设置的两个参数\n        self.httpapi_token = \"114514\"\n        self.httpapi_url = \"http://localhost:10087/MyQQHTTPAPI\"\n    \n    def send_pure_text_msg_2_person(self, target_qq:str, msg:str, robot_qq:str):\n        Values = {\n            \"function\" : \"Api_SendMsg\",\n            \"token\" : self.httpapi_token,\n            \"c1\" : robot_qq,\n            \"c2\" : \"1\",\n            \"c3\" : \"\",\n            \"c4\" : target_qq,\n            \"c5\" : msg\n        }\n        data = urllib.parse.urlencode(Values).encode(\"utf-8\") # 转码\n        rq = requests\n        rq = requests.get(self.httpapi_url, params=Values) # 发送请求\n        print(rq.content.decode(\"utf-8\")) # 打印服务器返回值\n```\n#### router\n\n##### 基本结构：\n\n```python\nfrom module.MSG_CALL_BACK import MSG_CALL_BACK\nfrom urllib.parse import unquote\n\n\nclass Router:\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def handle_post(item:MSG_CALL_BACK):\n        pass\n```\n\n用staticmethod修饰表示其不依赖其他的变量\n\n##### 消息转码\n\n先将获取到的消息进行转码\n\n```python\n    @staticmethod\n    def handle_post(item:MSG_CALL_BACK):\n        received_msg = unquote(item.MQ_msg)\n        print(\"收到消息：\", received_msg)\n```\n\n\n\n##### 判断消息类型\n\n由api列表可知，当MQ_type为1时表示消息来自好友聊天，我们在这里设置只回应私聊消息\n\n```python\n\t@staticmethod\n    def handle_post(item:MSG_CALL_BACK):\n        print(\"发送消息的qq号：\", item.MQ_fromQQ)\n        received_msg = unquote(item.MQ_msg)\n        print(\"消息为：\", received_msg) # 打印收到的具体消息\n        print(\"MQ_type：\", item.MQ_type) # 打印消息类型\n        if(item.MQ_type == 1):\n            # 如果不为1说明不是好友私聊，不做任何处理\n        \tpass     \t\n```\n\n增加了几条print信息，便于我们在控制台中查看\n\n\n\n##### 发送消息\n\n引入刚刚写好的msg_sender\n\n```python\nfrom business.msg_sender import MsgSender\n```\n\n对消息发送者做出回复\n\n```python\n    @staticmethod\n    def handle_post(item:MSG_CALL_BACK):\n        print(\"发送消息的qq号：\", item.MQ_fromQQ)\n        received_msg = unquote(item.MQ_msg)\n        print(\"消息为：\", received_msg) # 打印收到的具体消息\n        print(\"MQ_type：\", item.MQ_type) # 打印消息类型\n        if(item.MQ_type == 1):\n       \t\t# 如果不为1说明不是好友私聊，不做任何处理\n            response_msg = \"收到了你发的消息，你发的消息是：\" + received_msg\n            current_robot_qq = \"\" # 填入你的机器人qq号，目前先将其写死在程序中\n            MsgSender().send_pure_text_msg_2_person(item.MQ_fromQQ, response_msg , current_robot_qq)\n\n```\n\n##### router完整代码\n\n```python\nfrom module.MSG_CALL_BACK import MSG_CALL_BACK\nfrom urllib.parse import unquote\nfrom business.msg_sender import MsgSender\n\n\nclass Router:\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def handle_post(item:MSG_CALL_BACK):\n        print(\"发送消息的qq号：\", item.MQ_fromQQ)\n        received_msg = unquote(item.MQ_msg)\n        print(\"消息为：\", received_msg) # 打印收到的具体消息\n        print(\"MQ_type：\", item.MQ_type) # 打印消息类型\n        if(item.MQ_type == 1):\n            # 如果不为1说明不是好友私聊，不做任何处理\n            response_msg = \"收到了你发的消息，你发的消息是：\" + received_msg\n            current_robot_qq = \"\" # 填入你的机器人qq号，目前先将其写死在程序中\n            MsgSender().send_pure_text_msg_2_person(item.MQ_fromQQ, response_msg , current_robot_qq)\n```\n\n\n\n#### 改写main\n\n此时可以在`main.py`中引入router并将post中的数据传入\n\n```python\nfrom business.router import Router # 引入路由\n```\n\n```python\nfrom fastapi import FastAPI, Body\nfrom fastapi.middleware.cors import CORSMiddleware\nimport uvicorn\nfrom module.MSG_CALL_BACK import MSG_CALL_BACK # 引入模型类\nfrom business.router import Router # 引入路由\n\n\napp = FastAPI()\n# 解决跨域\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"]\n)\n\n@app.post('/')\ndef read_model(item:MSG_CALL_BACK = Body(...)):   \n    Router.handle_post(item) # 将接收到的消息转交给路由处理\n    return {\"status\":1}\n\nif __name__ == \"__main__\":   \n    uvicorn.run(app = app, host = \"0.0.0.0\", port = \"8000\")\n```\n\n## 试验消息收发功能\n\n在控制台中输入\n\n```bash\nuvicorn main:app --reload\n```\n\n启动服务器\n\n同时确保MyQQ机器人已经在线，并开启了HTTP API插件的服务\n\n![服务器启动](image-20211121173003878.png)\n\n此时我们写好的服务器已经开始工作了，我们发送一条消息试试\n\n![发送消息](image-20211121174258211.png)\n\n成功收到了机器人的回复，此时的控制台输出为\n\n![image-20211121174952539](image-20211121174952539.png)\n\n其中，前三行是我们打印的输出，第四行是MyQQ服务器的返回信息，告诉我们发送的消息已经被成功处理，第五行是本地服务器打印的信息，表示服务器被访问了\n\n## 结束\n\n一个简单的能处理输入输出的qq机器人就搭建完成了，后续还可以在此基础上增加各种功能，比如发送图片，自动点赞，自动发送天气预报，基于人工智能的自动聊天等等\n\n## 附件\n\n[本文的相关代码](code.zip)\n\n","tags":["编程","技术"],"categories":["qq机器人"]},{"title":"2021.4动画推荐","url":"/合集/动画推荐/2021.4 动画推荐/","content":"\n# 2021.4 动画推荐\n\n{% note warning %} \n\n**主观判断警告！**\n\n本文纯粹出于笔者个人主观经验与感受而成，如有任何不同意见欢迎友善交流讨论\n\n没有提到的作品笔者没看，或不符合笔者个人兴趣，或观看价值较低\n\n{% endnote %}\n\n## Vivy -Fluorite Eye’s Song-（薇薇 -萤石眼之歌-）\n推荐度：90分\n优秀的作画，流畅精彩的打斗，单元剧形式。主线类似于京紫，不过换成了歌姬ai拯救人类的过程中寻找真心真情的故事。\n关键词：`音乐`，`ai`，`治愈`，`战斗`\n\n## イジらないで、長瀞さん（别欺负我长瀞同学）\n推荐度：75分\n画面优秀的搞笑恋爱喜剧，和高木同学类似的发展，但比高木同学剧情更加活跃。是活泼黑皮少女与闷骚男的故事。\n关键词：`日常`，`喜剧`，`校园`，`恋爱`\n\n## シャドーハウス（影宅）\n推荐度：70\n画面优秀，oped具有特色，初期设定有趣，后续剧情比较平淡，半日常半闯关。\n关键词：`玄幻`，`轻百合`\n\n## 86―エイティシックス―（86-不存在的战区-）\n推荐度：60\n设定一般，剧情经不起推敲，女主白长直。白毛控与龙傲天爱好者可不带脑子尝试。总体水品属于一般。\n关键词：`白毛`，`机甲`，`战争`\n\n","tags":["二次元","动画"],"categories":["动画推荐"]},{"title":"我为什么喜欢砂糖","url":"/我为什么喜欢砂糖/","content":"\n# [Genshin] [原神] 我为什么喜欢砂糖\n\n## 简介\n\n`无害甜度` `西风骑士团炼金术师` `生日：11月26日` `命之座：烧瓶座` `神之眼：风`\n\n> 炼金术士砂糖在「生物炼金」这一领域成就斐然。\n>\n> 在其研究过程…或者，借用她的话：「在追求真理的道路上」，有时也会诞生出各类神秘产物。\n>\n> 能长出六倍种子、起风时让满城人不得不关窗闭门的超级蒲公英，连石砖都能划破的钩钩果，还有…跟南瓜长得差不多大的日落果。\n>\n> 以上这些成果给砂糖带来了巨大疑问，倒也让她的研究大步迈进。\n>\n> 然而，为它们起名字却是更为困难的事。对砂糖而言，比看见实验植株被人摘走或是研究用品被污染还要痛苦。\n>\n> 为一株花蜜浓稠如胶水的甜甜花命名时，时间就像河水一样疯狂地流走了。砂糖用尽心思，花费比为整片试验田人工授粉还长的时间后，总算取出了一个勉强算是名字的东西：\n>\n> 「这是第二十八株…性状…本来学名…」\n>\n> 「就、就叫它…玖式甜甜花改二十八号香味特化版好了！」\n\n众所周知，本人是砂糖厨，在原神众多角色中，唯独砂糖最令我倾心，本文旨在说明本人为何喜欢砂糖，表现砂糖的可爱与知性，让更多人认识到砂糖的魅力\n\n## 外貌\n\n![砂糖](砂糖.jpg)\n\n### 整体\n\n砂糖的主体色调是绿、蓝、白，发色是淡淡的青绿色。砂糖有着琥珀色的眼镜和白皙的皮肤，披着白色的披风，身着深蓝色裙子，裙摆是荷叶的样式，俏皮可爱，下半身着吊带黑丝，又显得成熟性感，脚踩白色长靴干练踏实\n\n### 细节\n\n- 砂糖的耳朵是兽耳，不过不像迪奥娜那样竖起，而是向下耷拉着的，表现了砂糖的稳重乖巧，这对毛茸茸的兽耳在砂糖走动时会上下跳动，十分可爱\n- 砂糖戴着眼镜，结合她炼金术师的身份，给人一种知性、典雅的美感\n- 砂糖的头发很长，只不过梳成了一股细细的长辫，粗略一看不太容易注意，如果将头发解开，定是柔顺漂亮的长发\n\n## 性格\n\n砂糖是炼金术师，她深深热爱着研究世界，她对炼金术的痴迷已经近乎狂热\n\n砂糖对知识的追求注定了她不仅仅只是一个徒有其表的花瓶\n砂糖不像可莉那样刻意卖萌，不像安柏那样热情好客、自来熟，也不像神里绫华那样对旅行者一见钟情，无条件倒贴\n她只是在认真的做自己喜欢的东西，她只是不断地追求知识的高峰\n不谄媚，不世俗，不平庸，正如她荷叶般的裙摆一样，她只是静静地开放，人们自然就能发现她纯洁的灵魂\n\n## 比较\n\n### 可莉\n\n- 可莉的精灵耳光秃秃的，不如砂糖这样毛茸茸的可爱\n- 可莉性格太过于幼稚，缺乏理性与内涵\n\n### 阿贝多\n\n- 不论性别，阿贝多的情感活动太过于平淡，虽然砂糖也喜欢研究，但她并不是无口无心之人\n\n### 凝光\n\n- 凝光高贵优雅，也是一个非常优秀的角色，但是凝光太过于尊贵，对她始终有距离感\n\n### 刻晴\n\n- 刻晴和砂糖类似，也有「认真」的标签，但是刻晴太过于一本正经，或者说太过于刻板，而且她相比砂糖更加的世俗，而砂糖则显得更加超然一些\n\n### 神里绫华\n\n- 神里绫华这个发型我不喜欢，这个发型其他角度看还好，从正面看实在令我不太能接受\n- 神里绫华作为神里家社交方面的核心人物，整日与钱、权打交道，而且她还是达官显贵的大小姐，这样的环境下成长出来的神里绫华，终究与一般人有一定的隔阂\n\n## 总结\n\n- 砂糖外貌可爱而又不张扬，矜持高雅\n- 砂糖衣着得体，搭配合理，不媚俗，不老土\n- 砂糖热爱研究，但又不呆板，反而更显她内在的充实，灵魂的丰满\n- 砂糖对世界充满好奇，富有探索精神，思维活跃，可见她的精神世界丰富多彩\n\n","tags":["二次元","游戏","原神"],"categories":["其他"]},{"title":"地形变观测方法","url":"/地形变观测方法/","content":"\n# 地形变观测技术\n\n## 写在前面\n\n\n{% note warning %}\n### 非专业预警\n\n作者并非相关专业人士，仅仅是把自己查到的资料做了一个总结记录，其中难免有错误或是不全面的部分，如果在文中发现任何错误，烦请在评论区中斧正\n\n{% endnote %}  \n\n\n## 什么是地形变\n\n> 地形变（ground deformation）又称地震形变，在地震发生时或地震前后，由于构造运动或地震构造力以及地震波振动作用，地表产生变形的现象\n\n## 地形变观测\n\n1. 地震会引起如塌方、河流改道等较为明显的地形变，这些可以通过遥感卫星或是航拍的方式，用肉眼直接观测到。\n\n2. 地震会在地球表面形成断层，这些断层在地震发生之后很长一段时间会让地表缓慢地滑落或是缓慢地移动，这种形变范围广、变化小、耗时长，需要用更加精确的GNSS技术来监测地震后的地形变化。\n\n**在这里主要讨论第二种**\n\n## 地形变观测技术-GNSS技术\n\n人们通过在地表建立大量的观测站组成观测网，来记录不同时间的地表位移，从而可以获取一整块地区的地形变。\n\n### DGPS\n\n> DGPS(Differential Global Positioning System)：差分全球定位系统。在位置已精确测定的已知点上配备一台 GPS 接收机作为基准站并和用户同时进行 GPS 观测，将得到的单点定位的结果与基准站坐标比较，求解出实时差分修正值，以广播或数据链传输方式，将差分修正值传送至附近 GPS用户，以修正其GPS定位解，提高其局部范围内用户的定位精度。\n\n**简单来说就是通过已知的精确坐标来修正GPS坐标，从而获得更高的精度。**\n\n### PPP\n\n> PPP(Precise Point Positioning)：精密单点定位技术。通过精确的卫星轨道和时间来获取高精度坐标。\n\n### 二者比较\n\n- 要使用DGPS**要求有一个定位精确的基准站**且能够收到它的信号，而且距离基准站越**远效果越差**。\n- PPP定位只需要单台GPS接收机就可以进行，由于只有单台接收机，所以**必须要持续接收一段时间的数据**才能获得精确值，通常大约要等待20分钟左右。\n- 可见，两者各有利弊。\n- 无论是DGPS还是PPP，它们的计算都非常繁琐，因此一般会由专门的机构计算这些从各个观测站收集到的卫星数据，并把计算结果发布出来。\n\n## 观测站——观测站实例\n\n- 图示是美国的一个名为`BayArea`的观测站网络，现在选中其中一个名为`BRI2`的观测站。\n\n![观测网](image-20211031181228931.png)\n\n![数据1](image-20211031181301883.png)\n\n<center>↑单独的观测数据↑</center>\n\n![数据2](image-20211031181317889.png)\n\n<center>↑年平均数据↑</center>\n\n- 先看单独的观测数据，第一行记录南北的位移，第二行记录东西的位移，第三行记录上下的位移。其中，蓝色的点表示正常记录，红色的点表示发生地震后的记录\n- 再看年平均数据，它就是把单独的数据求了个平均值，得到了该观测站的年平均位移\n\n##  观测研究实例——311日本地震\n\n2011年3月11日，在日本东北部太平洋海域发生9.0级地震，对日本造成了严重的灾难，以下是日本观测网对当时地震的记录\n\n![日本地震实例](image-20211031182057433.png)\n\n右方的绿色小星星是震源，左图表示横向位移，右图表示纵向位移，可以清晰地看到，日本陆地整体向东位移，并且东部下沉，西部上升\n\n汇总观测网中各个观测站的数据可以很容易感知到地震对陆地的影响\n\n## 观测地形变的作用\n\n### 反常地形变可能是地震发生的前兆？\n\n![某观测站记录的数据](image-20211031182954393.png)\n\n上图是某观测站在3月11日前10天记录的一组数据，可以看到观测站有明显向东偏的趋势，这与地震发生后的变化一致\n\n![多个观测站记录的数据](image-20211031183147226.png)\n\n这张图是多个观测站记录的数据，可以看到在3月9日其实还发生了一场7级的地震，许多观测站开始东偏的原因是这场地震，更有一些观测站，即使在3月9日之后仍然没有明显偏移，这样来看，或许地震前的地形变又无法说明地震即将到来\n\n{% note warning %} \n\n<h5>结论</h5>\n\n通过地形变是否能够预测地震到目前为止仍然**没有定论**，或许还需要更多观测数据和统计才能研究出结果吧 {% endnote %}  \n\n\n### **地震后的地形变可能对次生灾害造成影响？**\n\n日本作为一个沿海国家，最大的次生灾害便是海啸，陆地的平移翻动是否会影响海啸的影响范围和烈度？还有如汶川地震，地震后的地面运动是否会导致山体滑坡等灾害的发生概率提高？这些也是一个地形变可以研究的方向\n\n## 参考文献\n\n- [1] [Makoto KAMIYAMA, Hideo KOIDE, Yasuji SAWADA, et al. Monitoring of Crustal Deformation and Its Application to Mitigation of Earthquake Disasters[j]. Journal of JSCE, 2017(5):206-225](https://www.jstage.jst.go.jp/article/journalofjsce/5/1/5_206/_pdf)\n\n","tags":["科普","地球科学","地震"],"categories":["科普"]},{"title":"Python实现Web API","url":"/python实现webapi/","content":"\n{% note info %} \n\n## 基于FastAPI和uvicorn开发\n\n- FastAPI是一个高效的异步Web框架\n- uvicorn是快速的http服务器框架\n\n- 详情：[FastAPI](https://fastapi.tiangolo.com/zh/)  \n\n{% endnote %}\n\n\n\n## 代码示例\n\n``` python\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nimport uvicorn\n\n\napp = FastAPI()\n\n# 处理跨域\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"]\n)\n\n@app.get('/')\ndef read_root():\n    return {\"hello\" : \"world\"}\n\n@app.get(\"/items\")\ndef read_item(item_id:int, q:str = null):\n    return{\"item_id\" : item_id, \"msg\":q}\n\nif __name__ == '__main__':\n    uvicorn.run(app = app, host = \"0.0.0.0\", port = 8000)\n```\n\n`@app.post`下的函数处理post请求，`@app.post('/')`表示路由，本例中post的url为`localhost:8000`，如果改为`@app.post('/p')`，那么post时的url应为`localhost:8000/p`\n\n其他的请求同理\n\n## 运行服务器\n\n```bash\nuvicorn <填入文件名>:<填入FastAPI实例名> --reload\n```\n\n我的程序文件名为webtest.py，实例名为app，所以我的指令为：\n\n```bash\nuvicorn webtest:app --reload\n```\n\n完整指令是：\n\n```bash\nuvicorn <文件名>:<实例名> --reload --host 192.XXX.XXX --port xxxx\n```\n\n其中，reload是自动重启，修改源文件后服务器自动重启，后面的是指定主机地址和端口号，在实例程序中单独设置了，所以不需要再在命令行中设置\n\n相关文档：[Uvicorn](https://www.uvicorn.org/settings/)\n\n## HTML调用\n\nHTML调用与调用一般的REST API形式相同，这里使用jQuery发出请求\n\n```js\n$.get(\"http://127.0.0.1:8000/items\",\n{\n    \"item_id\" : 1\n},\nfunction(data){\n    console.log(data);\n})\n```\n\n![html发出get请求](image-20211026215907823.png)\n\n## 关于POST\n\n### POST基础实现\n\n如果你像网上很多示例一样写POST，并用jQuery调用\n\n后端：\n\n```python\n@app.post('/')\ndef read_model(msg:str):   \n    return {\"message\":msg}\n```\n\n前端：\n\n```javascript\n$.post(\"http://127.0.0.1:8000\",\n{\n    \"msg\" : \"测试数据\"\n},\nfunction(data){\n    console.log(data);\n},\n\"json\")\n```\n\n那么你会发现服务器返回422错误码，说你的数据格式不正确\n\n![post发生422错误](image-20211027075547192.png)\n\n这个问题之前在用.net core开发web api时就发现过，当时的解决方法是在参数前加上`[FromForm]`\n\n像这样：\n\n```c#\n// 这里是c#代码\n[HttpPost]\npublic void fun([FromForm] Item item)\n```\n\n这是因为看似jQuery传参是一个json，但实际上还是以Form形式传递的，在python这里也要这样操作，在参数后面加上`= Form(<参数>)`\n\n修改后的后端代码：\n\n```python\nfrom fastapi import FastAPI, Form\n\n@app.post('/')\ndef read_model(msg:str = Form(...)):   \n    return {\"message\":msg}\n```\n\n前端不用修改，这次可以正常POST了\n\n![成功post](image-20211027080336478.png)\n\n关于`Form(<para>)`中的参数\n\n- 如果写`Form(...)`表示这个参数不可省略\n- 如果写`Form(\"这是默认数据\")`表示这个参数缺省时的默认参数为一个字符串：\"这是默认数据\"\n- 如果写`Form(None)`表示这个参数缺省时的默认值为空\n\n{% note danger %} 注意：\n\n其他人和官方文档的基础示例中都没有指定Header、Body或是Form，本人学艺不精，并不清楚怎么向后端传递json格式的数据，只会用jQuery.ajax方法传参，所以必须用到`= Form(<para>)`的形式\n\n如果大佬了解其他传参方式，请务必在评论区中留言，感谢您的指导\n\n {% endnote %}\n\n### 使用模型类\n\n{% note info %} \n模型使用`pydantic`  \n详情：[pydantic](https://pydantic-docs.helpmanual.io/)\n\n{% endnote %}\n\n这里我尝试了好久也无法在使用模型类的情况下用jQuery实现post，用ajax指定各种数据类型也没用，直接敲url服务器拒绝访问，如果有大佬知道怎么操作的，请在在评论区留言，不胜感激\n\n\n我想开发web api主要是因为想要接收`MyQQ`机器人`HTMLAPI`的回调请求，虽然无法接收来自Form的post请求，但来自body的post请求还是可以接收到的\n\n创建模型类：\n\n```python\nfrom pydantic import BaseModel\n\nclass MSG_CALL_BACK(BaseModel):   \n    MQ_robot: str\n    MQ_type: int\n    MQ_type_sub: int\n    MQ_fromID: str\n    MQ_fromQQ: str\n    MQ_passiveQQ: str\n    MQ_msg: str\n    MQ_msgSeq: str\n    MQ_msgID: str\n    MQ_msgData: str\n    MQ_timestamp: str\n```\n\n编写post处理：\n\n```python\n@app.post('/')\ndef read_model(    \n    item:MSG_CALL_BACK):   \n    return {\"status\":1}\n```\n\n即使不指定item的类型在python中也是完全可行的，只不过指定类型后在取item中的值时会有代码提示，也便于代码的理解\n\n","tags":["编程","技术","网络"],"categories":["REST API"]}]